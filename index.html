<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>äº”ç›®ä¸¦ã¹ - ä¸¦åˆ—AIç‰ˆ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      color: #fff;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 12px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .mode-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #2d3748;
      color: #fff;
    }

    .mode-btn:hover {
      transform: translateY(-2px);
    }

    .mode-btn.active {
      background: #4299e1;
      box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
    }

    .ai-selector {
      display: none;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
      padding: 16px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .ai-selector.visible {
      display: flex;
    }

    .ai-row {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .ai-row-label {
      font-size: 0.85rem;
      width: 60px;
      text-align: right;
    }

    .level-btn {
      padding: 8px 12px;
      border: 2px solid #4a5568;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .level-btn:hover {
      transform: scale(1.05);
    }

    .level-btn.active {
      border-color: #4299e1;
      background: #4299e1;
    }

    .turn-btn {
      padding: 8px 16px;
      border: 2px solid #4a5568;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .turn-btn:hover {
      transform: scale(1.05);
    }

    .turn-btn.active {
      border-color: #f59e0b;
      background: #f59e0b;
    }

    .level-btn.ultimate {
      border-color: #a855f7;
      background: rgba(168, 85, 247, 0.2);
    }

    .level-btn.ultimate.active {
      background: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
      animation: ultimatePulse 2s infinite;
    }

    .personality-btn {
      padding: 6px 12px;
      border: 2px solid transparent;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      color: #fff;
    }

    .personality-btn.aggressive {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
    }
    .personality-btn.aggressive.active {
      background: #ef4444;
    }

    .personality-btn.defensive {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
    }
    .personality-btn.defensive.active {
      background: #3b82f6;
    }

    .personality-btn.balanced {
      background: rgba(34, 197, 94, 0.2);
      border-color: #22c55e;
    }
    .personality-btn.balanced.active {
      background: #22c55e;
    }

    @keyframes ultimatePulse {
      0%, 100% { box-shadow: 0 0 5px #a855f7; }
      50% { box-shadow: 0 0 20px #a855f7, 0 0 30px #6366f1; }
    }

    .ai-vs-ai-selector {
      display: none;
      flex-direction: column;
      gap: 16px;
      margin-bottom: 16px;
      padding: 16px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .ai-vs-ai-selector.visible {
      display: flex;
    }

    .ai-vs-ai-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: center;
    }

    .ai-config-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .ai-config-group label {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .ai-config-buttons {
      display: flex;
      gap: 4px;
    }

    .ai-config-btn {
      padding: 6px 10px;
      border: 2px solid #4a5568;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .ai-config-btn:hover {
      transform: scale(1.05);
    }

    .ai-config-btn.active {
      border-color: #4299e1;
      background: #4299e1;
    }

    .ai-config-btn.ultimate.active {
      border-color: #a855f7;
      background: #a855f7;
    }

    .personality-mini {
      padding: 4px 8px;
      border: 2px solid transparent;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
      color: #fff;
    }

    .personality-mini.aggressive { background: rgba(239, 68, 68, 0.3); border-color: #ef4444; }
    .personality-mini.aggressive.active { background: #ef4444; }
    .personality-mini.defensive { background: rgba(59, 130, 246, 0.3); border-color: #3b82f6; }
    .personality-mini.defensive.active { background: #3b82f6; }
    .personality-mini.balanced { background: rgba(34, 197, 94, 0.3); border-color: #22c55e; }
    .personality-mini.balanced.active { background: #22c55e; }

    .vs-label {
      font-size: 1.5rem;
      font-weight: bold;
      color: #f59e0b;
    }

    .battle-controls {
      display: none;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .battle-controls.visible {
      display: flex;
    }

    .battle-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .battle-btn.start { background: #22c55e; color: #fff; }
    .battle-btn.pause { background: #f59e0b; color: #fff; }
    .battle-btn.stop { background: #ef4444; color: #fff; }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.85rem;
    }

    .speed-control input { width: 80px; }

    .status {
      font-size: 1.1rem;
      margin-bottom: 12px;
      padding: 8px 20px;
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      transition: all 0.3s;
    }

    .status.winner {
      background: #22c55e;
      font-weight: bold;
      animation: winPulse 1s ease-in-out infinite;
    }

    @keyframes winPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .worker-status {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.75rem;
    }

    .worker-indicator {
      padding: 4px 8px;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      transition: all 0.2s;
    }

    .worker-indicator.active {
      background: #22c55e;
      animation: pulse 0.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .board-container {
      position: relative;
      touch-action: none;
    }

    canvas {
      display: block;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .ctrl-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #4a5568;
      color: #fff;
    }

    .ctrl-btn:hover {
      background: #5a6578;
      transform: translateY(-2px);
    }

    .ctrl-btn.primary {
      background: #48bb78;
    }

    .ctrl-btn.primary:hover {
      background: #38a169;
    }

    .score-board {
      display: flex;
      gap: 24px;
      margin-bottom: 12px;
      font-size: 1rem;
    }

    .score {
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
    }

    .score.black { border-left: 4px solid #1a1a1a; }
    .score.white { border-left: 4px solid #fff; }

  </style>
</head>
<body>
  <h1>ğŸ¯ äº”ç›®ä¸¦ã¹</h1>

  <div class="mode-selector">
    <button class="mode-btn active" data-mode="pvp">ğŸ‘¥ äºŒäººãƒ—ãƒ¬ã‚¤</button>
    <button class="mode-btn" data-mode="ai">ğŸ¤– AIå¯¾æˆ¦</button>
    <button class="mode-btn" data-mode="aivai">ğŸ¤–âš”ï¸ğŸ¤– AIåŒå£«</button>
  </div>

  <!-- AIå¯¾æˆ¦ç”¨ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ -->
  <div class="ai-selector" id="aiSelector">
    <div class="ai-row">
      <span class="ai-row-label">ã‚ãªãŸ:</span>
      <button class="turn-btn active" data-turn="black">âš« å…ˆæ‰‹</button>
      <button class="turn-btn" data-turn="white">âšª å¾Œæ‰‹</button>
    </div>
    <div class="ai-row">
      <span class="ai-row-label">ãƒ¬ãƒ™ãƒ«:</span>
      <button class="level-btn active" data-level="1">Lv.1</button>
      <button class="level-btn" data-level="2">Lv.2</button>
      <button class="level-btn" data-level="3">Lv.3</button>
      <button class="level-btn ultimate" data-level="4">ğŸ‘¹æœ€å¼·</button>
    </div>
    <div class="ai-row" id="personalityRow">
      <span class="ai-row-label">æ€§æ ¼:</span>
      <button class="personality-btn aggressive active" data-personality="aggressive">ğŸ”¥ æ”»æ’ƒ</button>
      <button class="personality-btn defensive" data-personality="defensive">ğŸ›¡ï¸ é˜²å¾¡</button>
      <button class="personality-btn balanced" data-personality="balanced">âš–ï¸ ãƒãƒ©ãƒ³ã‚¹</button>
    </div>
  </div>

  <!-- AIåŒå£«å¯¾æˆ¦ç”¨ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ -->
  <div class="ai-vs-ai-selector" id="aiVsAiSelector">
    <div class="ai-vs-ai-row">
      <div class="ai-config-group">
        <label>âš« é»’AI</label>
        <div class="ai-config-buttons" id="blackLevelBtns">
          <button class="ai-config-btn active" data-level="1">Lv1</button>
          <button class="ai-config-btn" data-level="2">Lv2</button>
          <button class="ai-config-btn" data-level="3">Lv3</button>
          <button class="ai-config-btn ultimate" data-level="4">ğŸ‘¹</button>
        </div>
        <div class="ai-config-buttons" id="blackPersonalityBtns">
          <button class="personality-mini aggressive active" data-personality="aggressive">ğŸ”¥</button>
          <button class="personality-mini defensive" data-personality="defensive">ğŸ›¡ï¸</button>
          <button class="personality-mini balanced" data-personality="balanced">âš–ï¸</button>
        </div>
      </div>
      
      <div class="vs-label">VS</div>
      
      <div class="ai-config-group">
        <label>âšª ç™½AI</label>
        <div class="ai-config-buttons" id="whiteLevelBtns">
          <button class="ai-config-btn" data-level="1">Lv1</button>
          <button class="ai-config-btn" data-level="2">Lv2</button>
          <button class="ai-config-btn" data-level="3">Lv3</button>
          <button class="ai-config-btn ultimate active" data-level="4">ğŸ‘¹</button>
        </div>
        <div class="ai-config-buttons" id="whitePersonalityBtns">
          <button class="personality-mini aggressive" data-personality="aggressive">ğŸ”¥</button>
          <button class="personality-mini defensive" data-personality="defensive">ğŸ›¡ï¸</button>
          <button class="personality-mini balanced active" data-personality="balanced">âš–ï¸</button>
        </div>
      </div>
    </div>
  </div>

  <div class="score-board">
    <div class="score black">âš« é»’: <span id="blackScore">0</span></div>
    <div class="score white">âšª ç™½: <span id="whiteScore">0</span></div>
  </div>

  <div class="status" id="status">é»’ã®ç•ªã§ã™</div>

  <div class="worker-status" id="workerStatus">
    <div class="worker-indicator" id="worker0">W1</div>
    <div class="worker-indicator" id="worker1">W2</div>
    <div class="worker-indicator" id="worker2">W3</div>
    <div class="worker-indicator" id="worker3">W4</div>
  </div>

  <div class="battle-controls" id="battleControls">
    <button class="battle-btn start" id="startBattleBtn">â–¶ï¸ é–‹å§‹</button>
    <button class="battle-btn pause" id="pauseBattleBtn">â¸ï¸ ä¸€æ™‚åœæ­¢</button>
    <button class="battle-btn stop" id="stopBattleBtn">â¹ï¸ åœæ­¢</button>
    <div class="speed-control">
      <label>é€Ÿåº¦:</label>
      <input type="range" id="battleSpeed" min="100" max="2000" value="500">
    </div>
  </div>

  <div class="board-container">
    <canvas id="board"></canvas>
  </div>

  <div class="controls">
    <button class="ctrl-btn" id="undoBtn">â†©ï¸ å¾…ã£ãŸ</button>
    <button class="ctrl-btn primary" id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>

  <script>
    // ========================================
    // Worker Code
    // ========================================
    // Worker Code - è©°ã¿ä¿è¨¼å‹AI
    // ã€Œè©°ã¿ç­‹ã ã‘ã‚’æ·±ãèª­ã‚€ã€é¸æŠçš„æ·±åº¦æ¢ç´¢
    // ========================================
    const workerCode = `
      const BOARD_SIZE = 15;
      const EMPTY = 0;
      const BLACK = 1;
      const WHITE = -1;
      const DIRECTIONS = [[1, 0], [0, 1], [1, 1], [1, -1]];

      let board = [];

      // ========================================
      // åŸºæœ¬åˆ¤å®šé–¢æ•°
      // ========================================
      
      function checkWin(x, y, player) {
        for (const [dx, dy] of DIRECTIONS) {
          let count = 1;
          for (let i = 1; i < 5; i++) {
            const nx = x + dx * i, ny = y + dy * i;
            if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
            if (board[ny][nx] !== player) break;
            count++;
          }
          for (let i = 1; i < 5; i++) {
            const nx = x - dx * i, ny = y - dy * i;
            if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
            if (board[ny][nx] !== player) break;
            count++;
          }
          if (count >= 5) return true;
        }
        return false;
      }

      // ========================================
      // ãƒ©ã‚¤ãƒ³è§£æï¼ˆé˜²å¾¡ç‚¹ã®å®Œå…¨åˆ—æŒ™ç”¨ï¼‰
      // ========================================
      
      function getLineInfo(x, y, dx, dy, player) {
        const line = [];
        for (let i = -4; i <= 4; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
            line.push({ i, x: nx, y: ny, cell: 'wall' });
          } else {
            const cell = board[ny][nx];
            line.push({ 
              i, x: nx, y: ny, 
              cell: cell === player ? 'mine' : cell === EMPTY ? 'empty' : 'enemy'
            });
          }
        }
        return line;
      }

      // ========================================
      // å½¢çŠ¶åˆ¤å®šï¼ˆçŸ³ãŒç½®ã‹ã‚Œã¦ã„ã‚‹çŠ¶æ…‹ã§å‘¼ã¶ï¼‰
      // ========================================
      
      function analyzePosition(x, y, player) {
        const result = {
          isFive: false,
          fours: [],      // { direction, defensePoints }
          openFours: [],  // é˜²å¾¡ä¸èƒ½
          openThrees: [], // { direction, defensePoints }
        };
        
        for (let dirIdx = 0; dirIdx < DIRECTIONS.length; dirIdx++) {
          const [dx, dy] = DIRECTIONS[dirIdx];
          const line = getLineInfo(x, y, dx, dy, player);
          
          // 5é€£ç¶šã®çª“ã‚’ã‚¹ãƒ©ã‚¤ãƒ‰
          for (let start = 0; start <= 4; start++) {
            const window = line.slice(start, start + 5);
            if (window.length < 5) continue;
            
            let mineCount = 0;
            let emptyCount = 0;
            let emptyPositions = [];
            let hasBlocker = false;
            
            for (const cell of window) {
              if (cell.cell === 'mine') mineCount++;
              else if (cell.cell === 'empty') {
                emptyCount++;
                emptyPositions.push({ x: cell.x, y: cell.y });
              }
              else hasBlocker = true;
            }
            
            if (mineCount === 5) {
              result.isFive = true;
            }
            
            if (mineCount === 4 && emptyCount === 1 && !hasBlocker) {
              const beforeIdx = start - 1;
              const afterIdx = start + 5;
              const before = line[beforeIdx];
              const after = line[afterIdx];
              const openBefore = before && before.cell === 'empty';
              const openAfter = after && after.cell === 'empty';
              
              if (openBefore && openAfter) {
                result.openFours.push({ direction: dirIdx });
              } else {
                result.fours.push({
                  direction: dirIdx,
                  defensePoints: emptyPositions.filter(p => 
                    p.x >= 0 && p.x < BOARD_SIZE && p.y >= 0 && p.y < BOARD_SIZE
                  )
                });
              }
            }
          }
          
          // é–‹æ”¾ä¸‰ãƒã‚§ãƒƒã‚¯ï¼ˆ6ãƒã‚¹çª“ï¼‰
          for (let start = 0; start <= 3; start++) {
            const window = line.slice(start, start + 6);
            if (window.length < 6) continue;
            
            if (window[0].cell !== 'empty' || window[5].cell !== 'empty') continue;
            
            const middle = window.slice(1, 5);
            let mineCount = 0;
            let emptyCount = 0;
            let emptyPositions = [];
            let hasBlocker = false;
            
            for (const cell of middle) {
              if (cell.cell === 'mine') mineCount++;
              else if (cell.cell === 'empty') {
                emptyCount++;
                emptyPositions.push({ x: cell.x, y: cell.y });
              }
              else hasBlocker = true;
            }
            
            if (mineCount === 3 && emptyCount === 1 && !hasBlocker) {
              const defPoints = [
                { x: window[0].x, y: window[0].y },
                { x: window[5].x, y: window[5].y },
                ...emptyPositions
              ].filter(p => p.x >= 0 && p.x < BOARD_SIZE && p.y >= 0 && p.y < BOARD_SIZE);
              
              result.openThrees.push({
                direction: dirIdx,
                defensePoints: defPoints
              });
            }
          }
        }
        
        return result;
      }

      // ========================================
      // çœŸã®åŒä¸‰åˆ¤å®šï¼ˆå½åŒä¸‰ã‚’æ’é™¤ï¼‰
      // ========================================
      
      function isRealDoubleThree(analysis) {
        if (analysis.openThrees.length < 2) return false;
        
        for (let i = 0; i < analysis.openThrees.length; i++) {
          for (let j = i + 1; j < analysis.openThrees.length; j++) {
            const t1 = analysis.openThrees[i];
            const t2 = analysis.openThrees[j];
            
            if (t1.direction === t2.direction) continue;
            
            const def1 = new Set(t1.defensePoints.map(p => p.x + ',' + p.y));
            const def2 = new Set(t2.defensePoints.map(p => p.x + ',' + p.y));
            
            let hasCommon = false;
            for (const d of def1) {
              if (def2.has(d)) { hasCommon = true; break; }
            }
            
            if (!hasCommon) return true;
          }
        }
        
        return false;
      }

      // ========================================
      // å³å‹ã¡åˆ¤å®š
      // ========================================
      
      function checkImmediateWin(x, y, player) {
        board[y][x] = player;
        const analysis = analyzePosition(x, y, player);
        board[y][x] = EMPTY;
        
        if (analysis.isFive) return { win: true, type: 'five' };
        if (analysis.openFours.length > 0) return { win: true, type: 'openFour' };
        
        const fourDirections = new Set(analysis.fours.map(f => f.direction));
        if (fourDirections.size >= 2) return { win: true, type: 'doubleFour' };
        
        if (analysis.fours.length > 0 && analysis.openThrees.length > 0) {
          for (const four of analysis.fours) {
            for (const three of analysis.openThrees) {
              if (four.direction !== three.direction) {
                return { win: true, type: 'fourThree' };
              }
            }
          }
        }
        
        board[y][x] = player;
        const isReal = isRealDoubleThree(analyzePosition(x, y, player));
        board[y][x] = EMPTY;
        if (isReal) return { win: true, type: 'doubleThree' };
        
        return { win: false };
      }

      // ========================================
      // å€™è£œæ‰‹ç”Ÿæˆ
      // ========================================
      
      function generateCandidatesInternal() {
        const candidateMap = new Map();
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x] !== EMPTY) {
              for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                  const ny = y + dy, nx = x + dx;
                  if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE && board[ny][nx] === EMPTY) {
                    candidateMap.set(nx + ',' + ny, { x: nx, y: ny });
                  }
                }
              }
            }
          }
        }
        return Array.from(candidateMap.values());
      }

      // ========================================
      // ã€é¸æŠçš„æ·±åº¦æ¢ç´¢ã€‘è©°ã¿ç­‹ã ã‘ã‚’æ·±ãèª­ã‚€
      // 
      // ãƒ»å¼·åˆ¶æ‰‹ï¼ˆå››ãƒ»é–‹æ”¾å››ãƒ»çœŸåŒä¸‰ï¼‰ã®ã¿æ·±åº¦å»¶é•·
      // ãƒ»é€šå¸¸æ‰‹ã¯å³åº§ã«æåˆˆã‚Š
      // ãƒ»ã€Œå››â†’é˜²å¾¡â†’å››ã€ãŒç¶šãé™ã‚Šè‡ªå‹•å»¶é•·
      // ãƒ»visited ã«æ‰‹ç•ª(player)ã‚’å«ã‚ã‚‹
      // ========================================
      
      // å¼·åˆ¶æ‰‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã€é˜²å¾¡ç‚¹ã‚’è¿”ã™
      function classifyMove(x, y, player) {
        board[y][x] = player;
        const analysis = analyzePosition(x, y, player);
        
        // å³å‹ã¡ã¯æœ€å„ªå…ˆ
        if (analysis.isFive) {
          board[y][x] = EMPTY;
          return { type: 'win', defensePoints: [] };
        }
        
        // é–‹æ”¾å››ï¼ˆé˜²å¾¡ä¸èƒ½ï¼‰
        if (analysis.openFours.length > 0) {
          board[y][x] = EMPTY;
          return { type: 'win', defensePoints: [] };
        }
        
        // åŒå››ï¼ˆé˜²å¾¡ä¸èƒ½ï¼‰
        const fourDirections = new Set(analysis.fours.map(f => f.direction));
        if (fourDirections.size >= 2) {
          board[y][x] = EMPTY;
          return { type: 'win', defensePoints: [] };
        }
        
        // å››ä¸‰ï¼ˆé˜²å¾¡ä¸èƒ½ï¼‰
        if (analysis.fours.length > 0 && analysis.openThrees.length > 0) {
          for (const four of analysis.fours) {
            for (const three of analysis.openThrees) {
              if (four.direction !== three.direction) {
                board[y][x] = EMPTY;
                return { type: 'win', defensePoints: [] };
              }
            }
          }
        }
        
        // çœŸã®åŒä¸‰ï¼ˆé˜²å¾¡ç‚¹ã‚’è¿”ã™ï¼‰
        if (isRealDoubleThree(analysis)) {
          const allDef = new Set();
          for (const three of analysis.openThrees) {
            three.defensePoints.forEach(p => allDef.add(p.x + ',' + p.y));
          }
          board[y][x] = EMPTY;
          return {
            type: 'forcing_doubleThree',
            defensePoints: [...allDef].map(s => {
              const [px, py] = s.split(',').map(Number);
              return { x: px, y: py };
            })
          };
        }
        
        // å››ï¼ˆå¼·åˆ¶æ‰‹ã€é˜²å¾¡ç‚¹ã‚’è¿”ã™ï¼‰
        if (analysis.fours.length > 0) {
          const allDef = new Set();
          for (const four of analysis.fours) {
            four.defensePoints.forEach(p => allDef.add(p.x + ',' + p.y));
          }
          board[y][x] = EMPTY;
          return {
            type: 'forcing_four',
            defensePoints: [...allDef].map(s => {
              const [px, py] = s.split(',').map(Number);
              return { x: px, y: py };
            })
          };
        }
        
        board[y][x] = EMPTY;
        return { type: 'normal', defensePoints: [] };
      }

      // ========================================
      // ã€æ ¸å¿ƒã€‘é¸æŠçš„æ·±åº¦ã®å¼·åˆ¶å‹åˆ©æ¢ç´¢
      // 
      // maxForcingMoves: å¼·åˆ¶æ‰‹ãŒä½•å›ç¶šã‘ã‚‰ã‚Œã‚‹ã‹
      // å¼·åˆ¶æ‰‹ã®ã¿ã‚’è¾¿ã‚Šã€é€šå¸¸æ‰‹ã¯æ¢ç´¢ã—ãªã„
      // ========================================
      
      function findForcedWinSelective(player, candidates, maxForcingMoves, visited) {
        if (maxForcingMoves <= 0) return null;
        const enemy = -player;
        
        // ã€æ”¹å–„6ã€‘visited ã«æ‰‹ç•ªã‚’å«ã‚ã‚‹
        const boardHash = player + ':' + board.flat().join('');
        if (visited.has(boardHash)) return null;
        visited.add(boardHash);

        // å¼·åˆ¶æ‰‹ã®ã¿ã‚’æŠ½å‡ºã—ã¦ã‚½ãƒ¼ãƒˆ
        const forcingMoves = [];
        
        for (const { x, y } of candidates) {
          const classification = classifyMove(x, y, player);
          
          if (classification.type === 'win') {
            // å³å‹ã¡ç™ºè¦‹
            return { x, y, type: 'immediate_win' };
          }
          
          if (classification.type === 'forcing_four' || classification.type === 'forcing_doubleThree') {
            forcingMoves.push({
              x, y,
              type: classification.type,
              defensePoints: classification.defensePoints
            });
          }
        }

        // å¼·åˆ¶æ‰‹ã‚’æ¢ç´¢ï¼ˆå››ã‚’å„ªå…ˆï¼‰
        forcingMoves.sort((a, b) => {
          if (a.type === 'forcing_four' && b.type !== 'forcing_four') return -1;
          if (a.type !== 'forcing_four' && b.type === 'forcing_four') return 1;
          return a.defensePoints.length - b.defensePoints.length;
        });

        for (const move of forcingMoves) {
          board[move.y][move.x] = player;
          
          // ã€æ”¹å–„4ã€‘é˜²å¾¡æ‰‹ã¯æœ€å°é›†åˆã®ã¿ã€å„é˜²å¾¡ã«å¯¾ã—ã¦ç¢ºèª
          let canWinAfterAllDefenses = true;
          
          for (const def of move.defensePoints) {
            board[def.y][def.x] = enemy;
            
            const nextCandidates = generateCandidatesInternal();
            
            // ã€é¸æŠçš„æ·±åº¦ã€‘å¼·åˆ¶æ‰‹ãŒç¶šããªã‚‰æ·±åº¦ã‚’è‡ªå‹•å»¶é•·
            const nextWin = findForcedWinSelective(
              player, 
              nextCandidates, 
              maxForcingMoves - 1,  // å¼·åˆ¶æ‰‹1å›æ¶ˆè²»
              visited
            );
            
            board[def.y][def.x] = EMPTY;
            
            if (!nextWin) {
              canWinAfterAllDefenses = false;
              break;
            }
          }
          
          board[move.y][move.x] = EMPTY;
          
          if (canWinAfterAllDefenses && move.defensePoints.length > 0) {
            return { x: move.x, y: move.y, type: move.type };
          }
        }

        return null;
      }

      // ========================================
      // ã€æ”¹å–„5ã€‘fallbackæ¢ç´¢ï¼ˆè² ã‘ã‚’æœ€ã‚‚é…ã‚‰ã›ã‚‹æ‰‹ï¼‰
      // ç›¸æ‰‹ã®å¼·åˆ¶å‹åˆ©ãŒä½•æ‰‹é…ã‚Œã‚‹ã‹ã§è©•ä¾¡
      // è©•ä¾¡é–¢æ•°ã¯ä½¿ç”¨ã—ãªã„
      // ========================================
      
      function findBestFallbackMove(player, candidates) {
        const enemy = -player;
        let bestMove = candidates[0];
        let bestDelayScore = -Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = player;
          
          const nextCandidates = generateCandidatesInternal();
          let delayScore = 0;
          
          // ç›¸æ‰‹ãŒå³å‹ã¡ã§ãã‚‹ã‹
          let enemyCanWinNow = false;
          for (const c of nextCandidates) {
            if (checkImmediateWin(c.x, c.y, enemy).win) {
              enemyCanWinNow = true;
              break;
            }
          }
          
          if (enemyCanWinNow) {
            delayScore = -10000; // å³è² ã‘
          } else {
            // ç›¸æ‰‹ã®å¼·åˆ¶å‹åˆ©ã‚’æ¢ã™ï¼ˆdepth=4ç›¸å½“ï¼‰
            const enemyWin = findForcedWinSelective(enemy, nextCandidates, 4, new Set());
            if (enemyWin) {
              delayScore = -1000; // å¼·åˆ¶è² ã‘
            } else {
              // è‡ªåˆ†ã®å¼·åˆ¶æ‰‹ãŒã‚ã‚‹ã‹
              const myForcing = findForcedWinSelective(player, nextCandidates, 2, new Set());
              if (myForcing) {
                delayScore = 500; // æ”»ã‚ã®ãƒãƒ£ãƒ³ã‚¹
              } else {
                // è‡ªåˆ†ãŒå››ã‚„ä¸‰ã‚’ä½œã‚Œã‚‹ã‹
                const classification = classifyMove(x, y, player);
                if (classification.type === 'forcing_four') {
                  delayScore = 100;
                } else if (classification.type === 'forcing_doubleThree') {
                  delayScore = 50;
                } else {
                  delayScore = 0;
                }
              }
            }
          }
          
          board[y][x] = EMPTY;
          
          if (delayScore > bestDelayScore) {
            bestDelayScore = delayScore;
            bestMove = { x, y };
          }
        }
        
        return bestMove;
      }

      // ========================================
      // Lv1-3ç”¨ã®é–¢æ•°ï¼ˆå¤‰æ›´ãªã—ï¼‰
      // ========================================
      
      function findImmediateWinSimple(player, candidates) {
        for (const { x, y } of candidates) {
          if (checkImmediateWin(x, y, player).win) return { x, y };
        }
        return null;
      }

      function findBlockSimple(player, candidates) {
        const enemy = -player;
        for (const { x, y } of candidates) {
          if (checkImmediateWin(x, y, enemy).win) return { x, y };
        }
        return null;
      }

      function findFourMove(player, candidates) {
        for (const { x, y } of candidates) {
          board[y][x] = player;
          const analysis = analyzePosition(x, y, player);
          board[y][x] = EMPTY;
          if (analysis.fours.length > 0) return { x, y };
        }
        return null;
      }

      function findOpenThreeMove(player, candidates) {
        for (const { x, y } of candidates) {
          board[y][x] = player;
          const analysis = analyzePosition(x, y, player);
          board[y][x] = EMPTY;
          if (analysis.openThrees.length > 0) return { x, y };
        }
        return null;
      }

      function findConnectedMove(player, candidates) {
        for (const { x, y } of candidates) {
          for (const [dx, dy] of DIRECTIONS) {
            for (const dir of [1, -1]) {
              const nx = x + dx * dir, ny = y + dy * dir;
              if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                if (board[ny][nx] === player) return { x, y };
              }
            }
          }
        }
        return candidates[0] || null;
      }

      // ========================================
      // ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
      // ========================================
      
      self.onmessage = function(e) {
        const { candidates, boardData, aiPlayer, level, personality, workerId } = e.data;
        
        board = boardData.map(row => [...row]);
        const enemy = -aiPlayer;

        // ========================================
        // ã€æœ€å¼·(Lv4)ã€‘è©°ã¿ä¿è¨¼å‹AI
        // å¼·åˆ¶æ‰‹ã®ã¿ã‚’æ·±ãèª­ã‚€é¸æŠçš„æ·±åº¦æ¢ç´¢
        // ========================================
        if (level === 4) {
          // ã€æ‰‹é †1ã€‘è‡ªåˆ†ã®å³å‹åˆ©ï¼ˆäº”é€£ï¼‰
          for (const { x, y } of candidates) {
            board[y][x] = aiPlayer;
            if (checkWin(x, y, aiPlayer)) {
              board[y][x] = EMPTY;
              self.postMessage({ workerId, bestMove: { x, y, reason: 'å³å‹åˆ©(äº”é€£)' }, bestScore: 1 });
              return;
            }
            board[y][x] = EMPTY;
          }

          // ã€æ‰‹é †2ã€‘è‡ªåˆ†ã®å¼·åˆ¶å‹åˆ©ï¼ˆè©°ã¿ï¼‰
          // maxForcingMoves=7: å››â†’é˜²å¾¡â†’å››â†’é˜²å¾¡â†’å››â†’é˜²å¾¡â†’äº” ã‚’èª­ã‚€
          const forcedWin = findForcedWinSelective(aiPlayer, candidates, 7, new Set());
          if (forcedWin) {
            forcedWin.reason = 'å¼·åˆ¶å‹åˆ©(' + (forcedWin.type || 'è©°ã¿') + ')';
            self.postMessage({ workerId, bestMove: forcedWin, bestScore: 1 });
            return;
          }

          // ã€æ‰‹é †3ã€‘ç›¸æ‰‹ã®å³å‹åˆ©é˜»æ­¢
          for (const { x, y } of candidates) {
            if (checkImmediateWin(x, y, enemy).win) {
              self.postMessage({ workerId, bestMove: { x, y, reason: 'ç›¸æ‰‹å³å‹åˆ©é˜»æ­¢' }, bestScore: 1 });
              return;
            }
          }

          // ã€æ‰‹é †4ã€‘ç›¸æ‰‹ã®å¼·åˆ¶å‹åˆ©é˜»æ­¢
          // ç›¸æ‰‹ãŒæ‰“ã£ãŸã‚‰å¼·åˆ¶å‹åˆ©ã«ãªã‚‹ç‚¹ã‚’æ¢ã™
          for (const { x, y } of candidates) {
            board[y][x] = enemy;
            const allCandidates = generateCandidatesInternal();
            const enemyWin = findForcedWinSelective(enemy, allCandidates, 5, new Set());
            board[y][x] = EMPTY;
            
            if (enemyWin) {
              self.postMessage({ workerId, bestMove: { x, y, reason: 'ç›¸æ‰‹å¼·åˆ¶å‹åˆ©é˜»æ­¢' }, bestScore: 1 });
              return;
            }
          }

          // ã€æ‰‹é †5ã€‘å‹ã¡ã‚‚è² ã‘ã‚‚ç„¡ã„å ´åˆï¼šæœ€ã‚‚æ•—åŒ—ã‚’é…ã‚‰ã›ã‚‹æ‰‹
          const fallbackMove = findBestFallbackMove(aiPlayer, candidates);
          fallbackMove.reason = 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯(æœ€å–„é˜²å¾¡)';
          self.postMessage({ workerId, bestMove: fallbackMove, bestScore: 1 });
          return;
        }

        // ========================================
        // Lv1-3ï¼ˆå¤‰æ›´ãªã—ï¼‰
        // ========================================
        
        const immediateWin = findImmediateWinSimple(aiPlayer, candidates);
        if (immediateWin) {
          immediateWin.reason = 'å³å‹åˆ©';
          self.postMessage({ workerId, bestMove: immediateWin, bestScore: 1 });
          return;
        }

        const block = findBlockSimple(aiPlayer, candidates);
        if (block) {
          block.reason = 'ç›¸æ‰‹é˜»æ­¢';
          self.postMessage({ workerId, bestMove: block, bestScore: 1 });
          return;
        }

        if (level === 3) {
          const forcedWin = findForcedWinSelective(aiPlayer, candidates, 4, new Set());
          if (forcedWin) {
            forcedWin.reason = 'å¼·åˆ¶å‹åˆ©';
            self.postMessage({ workerId, bestMove: forcedWin, bestScore: 1 });
            return;
          }
        }

        if (level >= 2) {
          const fourMove = findFourMove(aiPlayer, candidates);
          if (fourMove) {
            fourMove.reason = 'å››ã‚’ä½œã‚‹';
            self.postMessage({ workerId, bestMove: fourMove, bestScore: 1 });
            return;
          }
          
          const threeMove = findOpenThreeMove(aiPlayer, candidates);
          if (threeMove) {
            threeMove.reason = 'é–‹æ”¾ä¸‰ã‚’ä½œã‚‹';
            self.postMessage({ workerId, bestMove: threeMove, bestScore: 1 });
            return;
          }
        }

        const connectedMove = findConnectedMove(aiPlayer, candidates);
        const finalMove = connectedMove || candidates[0];
        if (finalMove) finalMove.reason = 'é€£çµæ‰‹';
        self.postMessage({ workerId, bestMove: finalMove, bestScore: 1 });
      };
    `;

    // ========================================
    // Constants
    // ========================================
    const BOARD_SIZE = 15;
    const EMPTY = 0;
    const BLACK = 1;
    const WHITE = -1;
    const NUM_WORKERS = 4;

    // ========================================
    // Game State
    // ========================================
    let board = [];
    let currentPlayer = BLACK;
    let gameOver = false;
    let moveHistory = [];
    let scores = { black: 0, white: 0 };
    let gameMode = 'pvp';
    let winner = null;  // å‹è€…ã‚’è¨˜éŒ²
    
    // AIè¨­å®šï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs AIï¼‰
    let aiLevel = 1;
    let aiPersonality = 'aggressive';
    let humanPlayer = BLACK;  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è‰²ï¼ˆå…ˆæ‰‹/å¾Œæ‰‹ï¼‰
    
    // AIåŒå£«å¯¾æˆ¦è¨­å®š
    let blackAi = { level: 1, personality: 'aggressive' };
    let whiteAi = { level: 4, personality: 'balanced' };
    
    let isAiThinking = false;
    let battleRunning = false;
    let battlePaused = false;
    let battleTimeoutId = null;

    let workers = [];
    let workerResults = [];
    let pendingWorkers = 0;
    let currentAiResolve = null;

    // ========================================
    // Worker Setup
    // ========================================
    function initWorkers() {
      workers.forEach(w => w.terminate());
      workers = [];

      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);

      for (let i = 0; i < NUM_WORKERS; i++) {
        const worker = new Worker(url);
        worker.onmessage = handleWorkerMessage;
        workers.push(worker);
      }
    }

    function handleWorkerMessage(e) {
      const { workerId, bestMove, bestScore } = e.data;
      
      workerResults.push({ workerId, bestMove, bestScore });
      document.getElementById('worker' + workerId).classList.remove('active');
      pendingWorkers--;

      if (pendingWorkers === 0 && currentAiResolve) {
        let best = workerResults[0];
        for (const result of workerResults) {
          if (result.bestScore > best.bestScore) {
            best = result;
          }
        }
        currentAiResolve(best.bestMove);
        currentAiResolve = null;
      }
    }

    function setWorkerActive(id, active) {
      const el = document.getElementById('worker' + id);
      if (active) el.classList.add('active');
      else el.classList.remove('active');
    }

    // ========================================
    // Canvas Setup
    // ========================================
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    let cellSize, padding, boardPixelSize;

    function initCanvas() {
      const maxSize = Math.min(window.innerWidth - 32, 500);
      boardPixelSize = maxSize;
      canvas.width = boardPixelSize;
      canvas.height = boardPixelSize;
      padding = boardPixelSize * 0.04;
      cellSize = (boardPixelSize - padding * 2) / (BOARD_SIZE - 1);
    }

    // ========================================
    // Board Rendering
    // ========================================
    function drawBoard() {
      ctx.fillStyle = '#dcb35c';
      ctx.fillRect(0, 0, boardPixelSize, boardPixelSize);

      ctx.strokeStyle = '#8b7355';
      ctx.lineWidth = 1;

      for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = padding + i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, padding);
        ctx.lineTo(pos, boardPixelSize - padding);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(padding, pos);
        ctx.lineTo(boardPixelSize - padding, pos);
        ctx.stroke();
      }

      const starPoints = [
        [3, 3], [3, 7], [3, 11],
        [7, 3], [7, 7], [7, 11],
        [11, 3], [11, 7], [11, 11]
      ];

      ctx.fillStyle = '#8b7355';
      starPoints.forEach(([x, y]) => {
        const px = padding + x * cellSize;
        const py = padding + y * cellSize;
        ctx.beginPath();
        ctx.arc(px, py, cellSize * 0.12, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawStones() {
      const lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            drawStone(x, y, board[y][x], lastMove && lastMove.x === x && lastMove.y === y);
          }
        }
      }
    }

    function drawStone(x, y, player, isLast = false) {
      const px = padding + x * cellSize;
      const py = padding + y * cellSize;
      const radius = cellSize * 0.43;

      ctx.beginPath();
      ctx.arc(px + 2, py + 2, radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fill();

      const gradient = ctx.createRadialGradient(
        px - radius * 0.3, py - radius * 0.3, radius * 0.1,
        px, py, radius
      );

      if (player === BLACK) {
        gradient.addColorStop(0, '#4a4a4a');
        gradient.addColorStop(1, '#1a1a1a');
      } else {
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(1, '#cccccc');
      }

      ctx.beginPath();
      ctx.arc(px, py, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      if (isLast) {
        ctx.beginPath();
        ctx.arc(px, py, radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = player === BLACK ? '#ff6b6b' : '#e74c3c';
        ctx.fill();
      }
    }

    function render() {
      drawBoard();
      drawStones();
    }

    // ========================================
    // Game Logic
    // ========================================
    function initBoard() {
      board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
      currentPlayer = BLACK;
      gameOver = false;
      winner = null;
      moveHistory = [];
      isAiThinking = false;
      updateStatus();
      render();
      
      // ========================================
      // ç ”ç©¶ç”¨ãƒ­ã‚°: ã‚²ãƒ¼ãƒ é–‹å§‹
      // ========================================
      const modeNames = { pvp: 'PvP', ai: 'vs AI', aivai: 'AI vs AI' };
      const levelNames = { 1: 'Lv1(å…¥é–€)', 2: 'Lv2(åˆç´š)', 3: 'Lv3(ä¸­ç´š)', 4: 'Lv4(æœ€å¼·)' };
      console.log('%c========================================', 'color: #06c;');
      console.log('%cæ–°è¦ã‚²ãƒ¼ãƒ é–‹å§‹', 'color: #06c; font-weight: bold; font-size: 14px;');
      console.log('ãƒ¢ãƒ¼ãƒ‰:', modeNames[gameMode] || gameMode);
      if (gameMode === 'ai') {
        console.log('AIãƒ¬ãƒ™ãƒ«:', levelNames[selectedLevel] || selectedLevel);
        console.log('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼:', humanPlayer === BLACK ? 'å…ˆæ‰‹(é»’)' : 'å¾Œæ‰‹(ç™½)');
      } else if (gameMode === 'aivai') {
        console.log('é»’AI:', levelNames[blackAiLevel] || blackAiLevel);
        console.log('ç™½AI:', levelNames[whiteAiLevel] || whiteAiLevel);
      }
      console.log('%c========================================', 'color: #06c;');
      
      // AIå¯¾æˆ¦ã§å¾Œæ‰‹ï¼ˆç™½ï¼‰ã‚’é¸ã‚“ã å ´åˆã€AIãŒå…ˆã«æ‰“ã¤
      if (gameMode === 'ai' && humanPlayer === WHITE) {
        triggerAiMove();
      }
    }

    function isValidMove(x, y) {
      return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[y][x] === EMPTY;
    }

    function makeMove(x, y, aiReason) {
      if (!isValidMove(x, y) || gameOver || isAiThinking) return false;

      board[y][x] = currentPlayer;
      moveHistory.push({ x, y, player: currentPlayer });

      // ========================================
      // ç ”ç©¶ç”¨ãƒ­ã‚°å‡ºåŠ›
      // ========================================
      const moveNum = moveHistory.length;
      const playerName = currentPlayer === BLACK ? 'é»’(BLACK)' : 'ç™½(WHITE)';
      const coord = String.fromCharCode(65 + x) + (15 - y); // A1ã€œO15å½¢å¼
      const isHuman = (gameMode === 'pvp') || 
                      (gameMode === 'ai' && currentPlayer === humanPlayer);
      const mover = isHuman ? 'Human' : 'AI';
      
      let logMessage = '[æ‰‹ç•ª ' + moveNum + '] ' + playerName + ' ' + mover + ': ' + coord + ' (' + x + ',' + y + ')';
      if (!isHuman && aiReason) {
        logMessage += ' ã€ç†ç”±: ' + aiReason + 'ã€‘';
      }
      
      console.log(
        '%c' + logMessage,
        'color: ' + (currentPlayer === BLACK ? '#333' : '#666') + '; font-weight: bold;'
      );

      if (checkWin(x, y, currentPlayer)) {
        gameOver = true;
        winner = currentPlayer;
        console.log('%c=== ã‚²ãƒ¼ãƒ çµ‚äº†: ' + playerName + ' ã®å‹åˆ© ===', 'color: #d33; font-weight: bold; font-size: 14px;');
        console.log('æ£‹è­œ:', moveHistory.map((m, i) => {
          const p = m.player === BLACK ? 'B' : 'W';
          const c = String.fromCharCode(65 + m.x) + (15 - m.y);
          return (i + 1) + '.' + p + c;
        }).join(' '));
        render();
        updateStatus();
        if (currentPlayer === BLACK) scores.black++;
        else scores.white++;
        updateScores();
        if (gameMode === 'aivai') stopBattle();
        return true;
      }

      if (checkDraw()) {
        gameOver = true;
        winner = null;
        console.log('%c=== ã‚²ãƒ¼ãƒ çµ‚äº†: å¼•ãåˆ†ã‘ ===', 'color: #999; font-weight: bold; font-size: 14px;');
        render();
        updateStatus();
        return true;
      }

      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
      updateStatus();
      render();

      // AIå¯¾æˆ¦ï¼šAIã®ç•ªãªã‚‰æ‰‹ã‚’æ‰“ã¤
      if (gameMode === 'ai' && currentPlayer !== humanPlayer && !gameOver) {
        triggerAiMove();
      }

      return true;
    }

    function undoMove() {
      if (moveHistory.length === 0 || gameOver || isAiThinking) return;

      const undoCount = gameMode === 'ai' && moveHistory.length >= 2 ? 2 : 1;
      
      for (let i = 0; i < undoCount && moveHistory.length > 0; i++) {
        const lastMove = moveHistory.pop();
        board[lastMove.y][lastMove.x] = EMPTY;
      }

      currentPlayer = moveHistory.length % 2 === 0 ? BLACK : WHITE;
      updateStatus();
      render();
    }

    const DIRECTIONS = [[1, 0], [0, 1], [1, 1], [1, -1]];

    function checkWin(x, y, player) {
      for (const [dx, dy] of DIRECTIONS) {
        let count = 1;
        for (let i = 1; i < 5; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }
        for (let i = 1; i < 5; i++) {
          const nx = x - dx * i, ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }
        if (count >= 5) return true;
      }
      return false;
    }

    function checkDraw() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === EMPTY) return false;
        }
      }
      return true;
    }

    // ========================================
    // AI
    // ========================================
    function generateCandidates() {
      if (moveHistory.length === 0) {
        return [{ x: 7, y: 7, priority: 1000000 }];
      }

      const candidateMap = new Map();
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            for (let dy = -2; dy <= 2; dy++) {
              for (let dx = -2; dx <= 2; dx++) {
                const ny = y + dy, nx = x + dx;
                if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE && board[ny][nx] === EMPTY) {
                  const key = `${nx},${ny}`;
                  if (!candidateMap.has(key)) {
                    const priority = quickEvaluate(nx, ny);
                    candidateMap.set(key, { x: nx, y: ny, priority });
                  }
                }
              }
            }
          }
        }
      }

      const candidates = Array.from(candidateMap.values());
      candidates.sort((a, b) => b.priority - a.priority);
      return candidates.slice(0, 24);
    }

    function quickEvaluate(x, y) {
      // å¼·åˆ¶æ‰‹é †å„ªå…ˆï¼šå‹ã¡ç¢ºå®šå½¢ã‚’é«˜ãè©•ä¾¡
      
      // å³å‹ã¡
      board[y][x] = WHITE;
      if (checkWin(x, y, WHITE)) { board[y][x] = EMPTY; return 100000000; }
      board[y][x] = BLACK;
      if (checkWin(x, y, BLACK)) { board[y][x] = EMPTY; return 95000000; }
      board[y][x] = EMPTY;

      const whiteThreats = analyzeThreatsMain(x, y, WHITE);
      const blackThreats = analyzeThreatsMain(x, y, BLACK);
      
      // é–‹æ”¾å››ï¼ˆæ­¢ã‚ã‚‰ã‚Œãªã„ï¼‰
      if (whiteThreats.openFour > 0) return 90000000;
      if (blackThreats.openFour > 0) return 85000000;
      
      // å››ä¸‰ãƒ»åŒå››ï¼ˆå‹ã¡ç¢ºå®šã‚³ãƒ³ãƒœï¼‰
      if (whiteThreats.four > 0 && whiteThreats.openThree > 0) return 80000000;
      if (whiteThreats.four >= 2) return 75000000;
      if (blackThreats.four > 0 && blackThreats.openThree > 0) return 70000000;
      if (blackThreats.four >= 2) return 65000000;
      
      // åŒä¸‰
      if (whiteThreats.openThree >= 2) return 60000000;
      if (blackThreats.openThree >= 2) return 55000000;

      // å››
      if (whiteThreats.four > 0) return 10000;
      if (blackThreats.four > 0) return 9000;
      
      // é–‹æ”¾ä¸‰
      if (whiteThreats.openThree > 0) return 5000;
      if (blackThreats.openThree > 0) return 4500;
      
      // é€£çµæ€§ï¼ˆå‹ã¡ç­‹ã«ã¤ãªãŒã‚‹å¯èƒ½æ€§ï¼‰
      let score = 0;
      for (const [dx, dy] of DIRECTIONS) {
        for (const dir of [1, -1]) {
          const nx = x + dx * dir, ny = y + dy * dir;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
            if (board[ny][nx] !== EMPTY) score += 50;
          }
        }
      }
      
      return score;
    }

    function findEmergencyMove(player) {
      const enemy = -player;
      const candidates = generateCandidates();

      // 1. è‡ªåˆ†ãŒå³å‹ã¡
      for (const { x, y } of candidates) {
        board[y][x] = player;
        const win = checkWin(x, y, player);
        board[y][x] = EMPTY;
        if (win) return { x, y };
      }

      // 2. ç›¸æ‰‹ã®å³å‹ã¡ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        board[y][x] = enemy;
        const lose = checkWin(x, y, enemy);
        board[y][x] = EMPTY;
        if (lose) return { x, y };
      }

      // 3. é–‹æ”¾å››ã‚’ä½œã‚‹
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.openFour > 0) return { x, y };
      }

      // 4. ç›¸æ‰‹ã®é–‹æ”¾å››ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.openFour > 0) return { x, y };
      }

      // 5. å››ä¸‰ã‚³ãƒ³ãƒœã‚’ä½œã‚‹ï¼ˆå‹ã¡ç¢ºå®šï¼‰
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.four > 0 && threats.openThree > 0) return { x, y };
      }

      // 6. åŒå››ã‚’ä½œã‚‹ï¼ˆå‹ã¡ç¢ºå®šï¼‰
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.four >= 2) return { x, y };
      }

      // 7. ç›¸æ‰‹ã®å››ä¸‰ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.four > 0 && threats.openThree > 0) return { x, y };
      }

      // 8. ç›¸æ‰‹ã®åŒå››ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.four >= 2) return { x, y };
      }

      // 9. åŒä¸‰ã‚’ä½œã‚‹ï¼ˆå¼·åŠ›ãªæ”»ã‚ï¼‰
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.openThree >= 2) return { x, y };
      }

      // 10. ç›¸æ‰‹ã®åŒä¸‰ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.openThree >= 2) return { x, y };
      }

      return null;
    }

    // ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ç”¨ã®è„…å¨åˆ†æ
    function analyzeThreatsMain(x, y, player) {
      const threats = { five: 0, openFour: 0, four: 0, openThree: 0, three: 0 };
      board[y][x] = player;
      
      for (const [dx, dy] of DIRECTIONS) {
        let count = 1;
        let openEnds = 0;
        
        // æ­£æ–¹å‘
        for (let i = 1; i <= 5; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] === player) count++;
          else if (board[ny][nx] === EMPTY) { openEnds++; break; }
          else break;
        }
        // è² æ–¹å‘
        for (let i = 1; i <= 5; i++) {
          const nx = x - dx * i, ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] === player) count++;
          else if (board[ny][nx] === EMPTY) { openEnds++; break; }
          else break;
        }
        
        count = Math.min(count, 5);
        if (count >= 5) threats.five++;
        else if (count === 4 && openEnds === 2) threats.openFour++;
        else if (count === 4 && openEnds === 1) threats.four++;
        else if (count === 3 && openEnds === 2) threats.openThree++;
        else if (count === 3 && openEnds === 1) threats.three++;
      }
      
      board[y][x] = EMPTY;
      return threats;
    }

    async function calculateAiMove(level, personality, player) {
      if (moveHistory.length === 0) {
        return { x: 7, y: 7 };
      }
      if (moveHistory.length === 1) {
        const first = moveHistory[0];
        const offsets = [[1, 1], [-1, -1], [1, -1], [-1, 1], [1, 0], [0, 1]];
        for (const [dx, dy] of offsets) {
          const nx = first.x + dx, ny = first.y + dy;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === EMPTY) {
            return { x: nx, y: ny };
          }
        }
      }

      const emergency = findEmergencyMove(player);
      if (emergency) return emergency;

      const candidates = generateCandidates();
      if (candidates.length === 0) return null;
      if (candidates.length === 1) return candidates[0];

      const chunkSize = Math.ceil(candidates.length / NUM_WORKERS);
      workerResults = [];
      pendingWorkers = NUM_WORKERS;

      return new Promise((resolve) => {
        currentAiResolve = resolve;

        for (let i = 0; i < NUM_WORKERS; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, candidates.length);
          const chunk = candidates.slice(start, end);

          if (chunk.length === 0) {
            pendingWorkers--;
            if (pendingWorkers === 0) {
              let best = workerResults[0];
              for (const r of workerResults) {
                if (r.bestScore > best.bestScore) best = r;
              }
              resolve(best.bestMove);
            }
            continue;
          }

          setWorkerActive(i, true);
          workers[i].postMessage({
            candidates: chunk,
            boardData: board.map(row => [...row]),
            aiPlayer: player,
            level: level,
            personality: personality,
            workerId: i
          });
        }
      });
    }

    async function triggerAiMove() {
      isAiThinking = true;
      updateStatus();

      // AIã¯äººé–“ã®åå¯¾ã®è‰²
      const aiPlayer = humanPlayer === BLACK ? WHITE : BLACK;
      const move = await calculateAiMove(aiLevel, aiPersonality, aiPlayer);
      
      isAiThinking = false;
      if (move && !gameOver) {
        makeMove(move.x, move.y, move.reason);
      }
    }

    // ========================================
    // AI vs AI Battle
    // ========================================
    function startBattle() {
      if (gameOver) initBoard();
      battleRunning = true;
      battlePaused = false;
      updateBattleButtons();
      runBattle();
    }

    function pauseBattle() {
      battlePaused = !battlePaused;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? 'â–¶ï¸ å†é–‹' : 'â¸ï¸ ä¸€æ™‚åœæ­¢';
      if (!battlePaused && battleRunning) runBattle();
    }

    function stopBattle() {
      battleRunning = false;
      battlePaused = false;
      if (battleTimeoutId) {
        clearTimeout(battleTimeoutId);
        battleTimeoutId = null;
      }
      isAiThinking = false;
      updateBattleButtons();
      updateStatus();
    }

    function updateBattleButtons() {
      document.getElementById('startBattleBtn').disabled = battleRunning && !battlePaused;
      document.getElementById('pauseBattleBtn').disabled = !battleRunning;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? 'â–¶ï¸ å†é–‹' : 'â¸ï¸ ä¸€æ™‚åœæ­¢';
    }

    async function runBattle() {
      if (!battleRunning || battlePaused || gameOver) return;

      isAiThinking = true;
      updateStatus();

      const currentAi = currentPlayer === BLACK ? blackAi : whiteAi;
      const move = await calculateAiMove(currentAi.level, currentAi.personality, currentPlayer);

      isAiThinking = false;

      if (move && !gameOver && battleRunning && !battlePaused) {
        makeMove(move.x, move.y, move.reason);

        if (!gameOver && battleRunning && !battlePaused) {
          const speed = parseInt(document.getElementById('battleSpeed').value);
          battleTimeoutId = setTimeout(runBattle, speed);
        }
      }
    }

    // ========================================
    // UI Updates
    // ========================================
    function getAiDisplayName(level, personality) {
      if (level === 4) return 'ğŸ‘¹æœ€å¼·';
      const icons = { aggressive: 'ğŸ”¥', defensive: 'ğŸ›¡ï¸', balanced: 'âš–ï¸' };
      return `Lv.${level}${icons[personality]}`;
    }

    function updateStatus() {
      const status = document.getElementById('status');
      status.classList.remove('winner');
      
      if (gameOver) {
        if (winner !== null) {
          status.classList.add('winner');
          const winnerName = winner === BLACK ? 'âš« é»’' : 'âšª ç™½';
          status.textContent = `${winnerName} ã®å‹åˆ©ï¼`;
        } else {
          status.textContent = 'å¼•ãåˆ†ã‘ï¼';
        }
      } else if (isAiThinking) {
        if (gameMode === 'aivai') {
          const ai = currentPlayer === BLACK ? blackAi : whiteAi;
          const name = getAiDisplayName(ai.level, ai.personality);
          status.textContent = `${currentPlayer === BLACK ? 'âš«' : 'âšª'} ${name} æ€è€ƒä¸­...`;
        } else {
          const name = getAiDisplayName(aiLevel, aiPersonality);
          status.textContent = `${name} æ€è€ƒä¸­...`;
        }
      } else {
        if (gameMode === 'aivai') {
          const ai = currentPlayer === BLACK ? blackAi : whiteAi;
          const name = getAiDisplayName(ai.level, ai.personality);
          status.textContent = `${currentPlayer === BLACK ? 'âš«' : 'âšª'} ${name} ã®ç•ª`;
        } else {
          status.textContent = currentPlayer === BLACK ? 'âš« é»’ã®ç•ªã§ã™' : 'âšª ç™½ã®ç•ªã§ã™';
        }
      }
    }

    function updateScores() {
      document.getElementById('blackScore').textContent = scores.black;
      document.getElementById('whiteScore').textContent = scores.white;
    }

    function updatePersonalityVisibility() {
      const row = document.getElementById('personalityRow');
      row.style.display = aiLevel === 4 ? 'none' : 'flex';
    }

    function updateAiVsAiPersonalityVisibility() {
      document.getElementById('blackPersonalityBtns').style.display = blackAi.level === 4 ? 'none' : 'flex';
      document.getElementById('whitePersonalityBtns').style.display = whiteAi.level === 4 ? 'none' : 'flex';
    }

    // ========================================
    // Event Handlers
    // ========================================
    function getGridPosition(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const gridX = Math.round((x - padding) / cellSize);
      const gridY = Math.round((y - padding) / cellSize);
      return { x: gridX, y: gridY };
    }

    canvas.addEventListener('click', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer !== humanPlayer) return;
      if (gameMode === 'aivai') return;

      const pos = getGridPosition(e.clientX, e.clientY);
      makeMove(pos.x, pos.y);
    });

    canvas.addEventListener('touchend', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer !== humanPlayer) return;
      if (gameMode === 'aivai') return;

      e.preventDefault();
      const touch = e.changedTouches[0];
      const pos = getGridPosition(touch.clientX, touch.clientY);
      makeMove(pos.x, pos.y);
    });

    // Mode buttons
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        
        document.getElementById('aiSelector').classList.toggle('visible', gameMode === 'ai');
        document.getElementById('aiVsAiSelector').classList.toggle('visible', gameMode === 'aivai');
        document.getElementById('battleControls').classList.toggle('visible', gameMode === 'aivai');
        document.getElementById('workerStatus').style.display = gameMode === 'pvp' ? 'none' : 'flex';
        
        stopBattle();
        initBoard();
      });
    });

    // Turn buttons (å…ˆæ‰‹/å¾Œæ‰‹)
    document.querySelectorAll('.turn-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.turn-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        humanPlayer = btn.dataset.turn === 'black' ? BLACK : WHITE;
        initBoard();
      });
    });

    // Level buttons (AIå¯¾æˆ¦)
    document.querySelectorAll('.ai-selector .level-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ai-selector .level-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiLevel = parseInt(btn.dataset.level);
        updatePersonalityVisibility();
        initBoard();
      });
    });

    // Personality buttons (AIå¯¾æˆ¦)
    document.querySelectorAll('.ai-selector .personality-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ai-selector .personality-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiPersonality = btn.dataset.personality;
        initBoard();
      });
    });

    // Black AI config (AIåŒå£«)
    document.querySelectorAll('#blackLevelBtns .ai-config-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#blackLevelBtns .ai-config-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        blackAi.level = parseInt(btn.dataset.level);
        updateAiVsAiPersonalityVisibility();
      });
    });

    document.querySelectorAll('#blackPersonalityBtns .personality-mini').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#blackPersonalityBtns .personality-mini').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        blackAi.personality = btn.dataset.personality;
      });
    });

    // White AI config (AIåŒå£«)
    document.querySelectorAll('#whiteLevelBtns .ai-config-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#whiteLevelBtns .ai-config-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        whiteAi.level = parseInt(btn.dataset.level);
        updateAiVsAiPersonalityVisibility();
      });
    });

    document.querySelectorAll('#whitePersonalityBtns .personality-mini').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#whitePersonalityBtns .personality-mini').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        whiteAi.personality = btn.dataset.personality;
      });
    });

    // Battle controls
    document.getElementById('startBattleBtn').addEventListener('click', startBattle);
    document.getElementById('pauseBattleBtn').addEventListener('click', pauseBattle);
    document.getElementById('stopBattleBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });

    // Other controls
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('resetBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });

    window.addEventListener('resize', () => {
      initCanvas();
      render();
    });

    // ========================================
    // Initialize
    // ========================================
    document.getElementById('workerStatus').style.display = 'none';
    initWorkers();
    initCanvas();
    initBoard();
  </script>
</body>
</html>
