<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>‰∫îÁõÆ‰∏¶„Åπ - ‰∏¶ÂàóAIÁâà</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      color: #fff;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 12px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .mode-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #2d3748;
      color: #fff;
    }

    .mode-btn:hover {
      transform: translateY(-2px);
    }

    .mode-btn.active {
      background: #4299e1;
      box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
    }

    .ai-types {
      display: none;
      gap: 6px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .ai-types.visible {
      display: flex;
    }

    .ai-btn {
      padding: 8px 16px;
      border: 2px solid transparent;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      color: #fff;
    }

    .ai-btn.aggressive {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
    }

    .ai-btn.aggressive.active {
      background: #ef4444;
    }

    .ai-btn.defensive {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
    }

    .ai-btn.defensive.active {
      background: #3b82f6;
    }

    .ai-btn.strategic {
      background: rgba(34, 197, 94, 0.2);
      border-color: #22c55e;
    }

    .ai-btn.strategic.active {
      background: #22c55e;
    }

    .ai-btn.ultimate {
      background: rgba(168, 85, 247, 0.2);
      border-color: #a855f7;
    }

    .ai-btn.ultimate.active {
      background: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
      animation: ultimatePulse 2s infinite;
    }

    @keyframes ultimatePulse {
      0%, 100% { box-shadow: 0 0 5px #a855f7; }
      50% { box-shadow: 0 0 20px #a855f7, 0 0 30px #6366f1; }
    }

    .ai-vs-ai-selector {
      display: none;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .ai-vs-ai-selector.visible {
      display: flex;
    }

    .ai-select-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .ai-select-group label {
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ai-select-buttons {
      display: flex;
      gap: 4px;
    }

    .ai-select-btn {
      width: 40px;
      height: 40px;
      border: 2px solid #4a5568;
      border-radius: 8px;
      background: rgba(255,255,255,0.1);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .ai-select-btn:hover {
      transform: scale(1.1);
    }

    .ai-select-btn.aggressive.active { border-color: #ef4444; background: rgba(239,68,68,0.3); }
    .ai-select-btn.defensive.active { border-color: #3b82f6; background: rgba(59,130,246,0.3); }
    .ai-select-btn.strategic.active { border-color: #22c55e; background: rgba(34,197,94,0.3); }
    .ai-select-btn.ultimate.active { border-color: #a855f7; background: rgba(168,85,247,0.3); }

    .vs-label {
      font-size: 1.5rem;
      font-weight: bold;
      color: #f59e0b;
    }

    .battle-controls {
      display: none;
      gap: 8px;
      margin-bottom: 12px;
    }

    .battle-controls.visible {
      display: flex;
    }

    .battle-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .battle-btn.start {
      background: #22c55e;
      color: #fff;
    }

    .battle-btn.pause {
      background: #f59e0b;
      color: #fff;
    }

    .battle-btn.stop {
      background: #ef4444;
      color: #fff;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.85rem;
    }

    .speed-control input {
      width: 80px;
    }

    .status {
      font-size: 1.1rem;
      margin-bottom: 12px;
      padding: 8px 20px;
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .worker-status {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.75rem;
    }

    .worker-indicator {
      padding: 4px 8px;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      transition: all 0.2s;
    }

    .worker-indicator.active {
      background: #22c55e;
      animation: pulse 0.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .board-container {
      position: relative;
      touch-action: none;
    }

    canvas {
      display: block;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .ctrl-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #4a5568;
      color: #fff;
    }

    .ctrl-btn:hover {
      background: #5a6578;
      transform: translateY(-2px);
    }

    .ctrl-btn:active {
      transform: translateY(0);
    }

    .ctrl-btn.primary {
      background: #48bb78;
    }

    .ctrl-btn.primary:hover {
      background: #38a169;
    }

    .score-board {
      display: flex;
      gap: 24px;
      margin-bottom: 12px;
      font-size: 1rem;
    }

    .score {
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
    }

    .score.black {
      border-left: 4px solid #1a1a1a;
    }

    .score.white {
      border-left: 4px solid #fff;
    }

    .winner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .winner-overlay.visible {
      display: flex;
    }

    .winner-modal {
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      padding: 32px 48px;
      border-radius: 16px;
      text-align: center;
      animation: popIn 0.3s ease-out;
    }

    @keyframes popIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .winner-modal h2 {
      font-size: 2rem;
      margin-bottom: 16px;
    }

    .winner-modal .stone-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      margin: 0 auto 16px;
    }

    .winner-modal .stone-icon.black {
      background: radial-gradient(circle at 30% 30%, #4a4a4a, #1a1a1a);
    }

    .winner-modal .stone-icon.white {
      background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    }

    .winner-modal button {
      margin-top: 16px;
      padding: 12px 32px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      background: #4299e1;
      color: #fff;
      transition: all 0.2s;
    }

    .winner-modal button:hover {
      background: #3182ce;
    }
  </style>
</head>
<body>
  <h1>üéØ ‰∫îÁõÆ‰∏¶„Åπ <span style="font-size:0.6em;color:#a855f7;">4‰∏¶ÂàóAI</span></h1>

  <div class="mode-selector">
    <button class="mode-btn active" data-mode="pvp">üë• ‰∫å‰∫∫„Éó„É¨„Ç§</button>
    <button class="mode-btn" data-mode="ai">ü§ñ AIÂØæÊà¶</button>
    <button class="mode-btn" data-mode="aivai">ü§ñ‚öîÔ∏èü§ñ AIÂêåÂ£´</button>
  </div>

  <div class="ai-types" id="aiTypes">
    <button class="ai-btn aggressive active" data-ai="aggressive">üî• ÊîªÊíÉÂûã</button>
    <button class="ai-btn defensive" data-ai="defensive">üõ°Ô∏è Èò≤Âæ°Âûã</button>
    <button class="ai-btn strategic" data-ai="strategic">‚öñÔ∏è „Éê„É©„É≥„ÇπÂûã</button>
    <button class="ai-btn ultimate" data-ai="ultimate">üëπ ÊúÄÂº∑</button>
  </div>

  <div class="ai-vs-ai-selector" id="aiVsAiSelector">
    <div class="ai-select-group">
      <label>‚ö´ ÈªíAI</label>
      <div class="ai-select-buttons" id="blackAiButtons">
        <button class="ai-select-btn aggressive active" data-ai="aggressive">üî•</button>
        <button class="ai-select-btn defensive" data-ai="defensive">üõ°Ô∏è</button>
        <button class="ai-select-btn strategic" data-ai="strategic">‚öñÔ∏è</button>
        <button class="ai-select-btn ultimate" data-ai="ultimate">üëπ</button>
      </div>
    </div>
    <div class="vs-label">VS</div>
    <div class="ai-select-group">
      <label>‚ö™ ÁôΩAI</label>
      <div class="ai-select-buttons" id="whiteAiButtons">
        <button class="ai-select-btn aggressive" data-ai="aggressive">üî•</button>
        <button class="ai-select-btn defensive" data-ai="defensive">üõ°Ô∏è</button>
        <button class="ai-select-btn strategic" data-ai="strategic">‚öñÔ∏è</button>
        <button class="ai-select-btn ultimate active" data-ai="ultimate">üëπ</button>
      </div>
    </div>
  </div>

  <div class="score-board">
    <div class="score black">‚ö´ Èªí: <span id="blackScore">0</span></div>
    <div class="score white">‚ö™ ÁôΩ: <span id="whiteScore">0</span></div>
  </div>

  <div class="status" id="status">Èªí„ÅÆÁï™„Åß„Åô</div>

  <div class="worker-status" id="workerStatus">
    <div class="worker-indicator" id="worker0">W1</div>
    <div class="worker-indicator" id="worker1">W2</div>
    <div class="worker-indicator" id="worker2">W3</div>
    <div class="worker-indicator" id="worker3">W4</div>
  </div>

  <div class="battle-controls" id="battleControls">
    <button class="battle-btn start" id="startBattleBtn">‚ñ∂Ô∏è ÈñãÂßã</button>
    <button class="battle-btn pause" id="pauseBattleBtn">‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢</button>
    <button class="battle-btn stop" id="stopBattleBtn">‚èπÔ∏è ÂÅúÊ≠¢</button>
    <div class="speed-control">
      <label>ÈÄüÂ∫¶:</label>
      <input type="range" id="battleSpeed" min="100" max="2000" value="500">
    </div>
  </div>

  <div class="board-container">
    <canvas id="board"></canvas>
  </div>

  <div class="controls">
    <button class="ctrl-btn" id="undoBtn">‚Ü©Ô∏è ÂæÖ„Å£„Åü</button>
    <button class="ctrl-btn primary" id="resetBtn">üîÑ „É™„Çª„ÉÉ„Éà</button>
  </div>

  <div class="winner-overlay" id="winnerOverlay">
    <div class="winner-modal">
      <div class="stone-icon" id="winnerStone"></div>
      <h2 id="winnerText">Èªí„ÅÆÂãù„Å°ÔºÅ</h2>
      <button id="playAgainBtn">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
    </div>
  </div>

  <script>
    // ========================================
    // Worker Code (ÊñáÂ≠óÂàó„Å®„Åó„Å¶ÂÆöÁæ©)
    // ========================================
    const workerCode = `
      const BOARD_SIZE = 15;
      const EMPTY = 0;
      const BLACK = 1;
      const WHITE = -1;

      const DIRECTIONS = [
        [1, 0], [0, 1], [1, 1], [1, -1]
      ];

      const PATTERN_SCORES = {
        FIVE: 10000000,
        OPEN_FOUR: 500000,
        FOUR: 50000,
        OPEN_THREE: 10000,
        THREE: 1000,
        OPEN_TWO: 500,
        TWO: 100,
        CENTER: 20
      };

      const PATTERN_DICT = {
        // ‰∫îÈÄ£ÔºàÂãù„Å°Ôºâ
        'XXXXX': 10000000,
        
        // ÈñãÊîæÂõõÔºàÊ¨°„ÅßÂãù„Å°Á¢∫ÂÆöÔºâ
        '_XXXX_': 5000000,
        
        // ÂõõÔºàÁâáÂÅ¥Èñâ„ÅòÔºâ
        'XXXX_': 500000,
        '_XXXX': 500000,
        'OXXXX_': 500000,
        '_XXXXO': 500000,
        
        // È£õ„Å≥ÂõõÔºà1„Å§Á©∫„Åç„Åå„ÅÇ„ÇãÂõõÔºâ
        'XXX_X': 400000,
        'XX_XX': 400000,
        'X_XXX': 400000,
        '_XXX_X': 400000,
        'X_XXX_': 400000,
        '_XX_XX': 400000,
        'XX_XX_': 400000,
        
        // ÈñãÊîæ‰∏âÔºà‰∏°ÂÅ¥Á©∫„Åç - ÈùûÂ∏∏„Å´Âç±Èô∫Ôºâ
        '_XXX_': 50000,
        '__XXX__': 50000,
        
        // È£õ„Å≥‰∏âÔºàÈñãÊîæÔºâ
        '_XX_X_': 40000,
        '_X_XX_': 40000,
        '_X_X_X_': 30000,
        
        // Áâá‰∏â
        'XXX__': 8000,
        '__XXX': 8000,
        'OXXX__': 8000,
        '__XXXO': 8000,
        
        // È£õ„Å≥‰∏âÔºàÁâáÔºâ
        'XX__X': 6000,
        'X__XX': 6000,
        'XX_X_': 6000,
        '_X_XX': 6000,
        'X_X_X': 5000,
        
        // ÈñãÊîæ‰∫å
        '_XX_': 3000,
        '__XX__': 3000,
        '_XX__': 2000,
        '__XX_': 2000,
        
        // È£õ„Å≥‰∫å
        '_X_X_': 2500,
        'X__X': 1500,
        
        // Áâá‰∫å
        'XX___': 500,
        '___XX': 500,
        'OXX___': 500,
        '___XXO': 500,
        
        // ÂçòÁü≥Ôºà‰∏≠Â§ÆÂØÑ„Çä„Éú„Éº„Éä„Çπ„ÅßË£úÂÆåÔºâ
        '_X_': 100,
      };

      const AI_CONFIG = {
        aggressive: { depth: 2, attackMult: 1.3, defenseMult: 0.8 },
        defensive:  { depth: 2, attackMult: 0.8, defenseMult: 1.4 },
        strategic:  { depth: 3, attackMult: 1.0, defenseMult: 1.0 },
        ultimate:   { depth: 4, attackMult: 1.0, defenseMult: 1.0 }
      };

      let board = [];
      let transpositionTable = new Map();
      const MAX_TT_SIZE = 50000;

      // Zobrist (WorkerÂÜÖ„ÅßÂàùÊúüÂåñ)
      let zobristTable = [];
      function initZobrist(seed) {
        // „Ç∑„Éº„Éâ‰ªò„Åç‰π±Êï∞
        let s = seed;
        const rand = () => { s = (s * 1103515245 + 12345) & 0x7fffffff; return s; };
        
        zobristTable = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
          zobristTable[y] = [];
          for (let x = 0; x < BOARD_SIZE; x++) {
            zobristTable[y][x] = {
              [BLACK]: rand(),
              [WHITE]: rand()
            };
          }
        }
      }

      function computeHash() {
        let hash = 0;
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x] !== EMPTY) {
              hash ^= zobristTable[y][x][board[y][x]];
            }
          }
        }
        return hash;
      }

      function checkWin(x, y, player) {
        for (const [dx, dy] of DIRECTIONS) {
          let count = 1;
          for (let i = 1; i < 5; i++) {
            const nx = x + dx * i, ny = y + dy * i;
            if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
            if (board[ny][nx] !== player) break;
            count++;
          }
          for (let i = 1; i < 5; i++) {
            const nx = x - dx * i, ny = y - dy * i;
            if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
            if (board[ny][nx] !== player) break;
            count++;
          }
          if (count >= 5) return true;
        }
        return false;
      }

      function lineToPattern(line, player) {
        let pattern = '';
        for (const cell of line) {
          if (cell === player) pattern += 'X';
          else if (cell === EMPTY) pattern += '_';
          else pattern += 'O';
        }
        return pattern;
      }

      function evaluateLinePatterns(startX, startY, dx, dy, player) {
        let score = 0;
        const line = [];
        let x = startX, y = startY;
        while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
          line.push(board[y][x]);
          x += dx;
          y += dy;
        }
        for (let i = 0; i <= line.length - 5; i++) {
          const window5 = line.slice(i, i + 5);
          const pattern5 = lineToPattern(window5, player);
          if (!pattern5.includes('O')) {
            for (const [pat, val] of Object.entries(PATTERN_DICT)) {
              if (pattern5.includes(pat) || pat.includes(pattern5)) {
                score += val;
              }
            }
          }
        }
        return score;
      }

      function evaluateBoard(player) {
        let score = 0;
        const enemy = -player;
        
        // „É©„Ç§„É≥Ë©ï‰æ°
        for (let y = 0; y < BOARD_SIZE; y++) {
          score += evaluateLinePatterns(0, y, 1, 0, player);
          score -= evaluateLinePatterns(0, y, 1, 0, enemy) * 1.2;
        }
        for (let x = 0; x < BOARD_SIZE; x++) {
          score += evaluateLinePatterns(x, 0, 0, 1, player);
          score -= evaluateLinePatterns(x, 0, 0, 1, enemy) * 1.2;
        }
        for (let x = 0; x < BOARD_SIZE; x++) {
          score += evaluateLinePatterns(x, 0, 1, 1, player);
          score -= evaluateLinePatterns(x, 0, 1, 1, enemy) * 1.2;
        }
        for (let y = 1; y < BOARD_SIZE; y++) {
          score += evaluateLinePatterns(0, y, 1, 1, player);
          score -= evaluateLinePatterns(0, y, 1, 1, enemy) * 1.2;
        }
        for (let x = 0; x < BOARD_SIZE; x++) {
          score += evaluateLinePatterns(x, BOARD_SIZE - 1, 1, -1, player);
          score -= evaluateLinePatterns(x, BOARD_SIZE - 1, 1, -1, enemy) * 1.2;
        }
        for (let y = 0; y < BOARD_SIZE - 1; y++) {
          score += evaluateLinePatterns(0, y, 1, -1, player);
          score -= evaluateLinePatterns(0, y, 1, -1, enemy) * 1.2;
        }
        
        // ‰∏≠Â§ÆÂà∂Âúß„Éú„Éº„Éä„ÇπÔºàÂº∑ÂåñÔºâ
        for (let y = 4; y <= 10; y++) {
          for (let x = 4; x <= 10; x++) {
            if (board[y][x] === player) {
              const centerDist = Math.abs(x - 7) + Math.abs(y - 7);
              score += (7 - centerDist) * 50 + 100;
            }
          }
        }
        
        // ÈÄ£Áµê„Éú„Éº„Éä„ÇπÔºàÁü≥„ÅåÁπã„Åå„Å£„Å¶„ÅÑ„Çã„Åª„Å©ÊúâÂà©Ôºâ
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x] === player) {
              let connections = 0;
              for (const [dx, dy] of DIRECTIONS) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                  if (board[ny][nx] === player) connections++;
                }
              }
              score += connections * 30;
            }
          }
        }
        
        return score;
      }

      function analyzeLinePattern(x, y, dx, dy, player) {
        let count = 1;
        let openEnds = 0;
        for (let i = 1; i <= 5; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          const cell = board[ny][nx];
          if (cell === player) count++;
          else if (cell === EMPTY) { openEnds++; break; }
          else break;
        }
        for (let i = 1; i <= 5; i++) {
          const nx = x - dx * i, ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          const cell = board[ny][nx];
          if (cell === player) count++;
          else if (cell === EMPTY) { openEnds++; break; }
          else break;
        }
        return { count: Math.min(count, 5), openEnds };
      }

      function analyzeThreats(x, y, player) {
        const threats = { five: 0, openFour: 0, four: 0, openThree: 0, three: 0 };
        board[y][x] = player;
        for (const [dx, dy] of DIRECTIONS) {
          const result = analyzeLinePattern(x, y, dx, dy, player);
          if (result.count >= 5) threats.five++;
          else if (result.count === 4 && result.openEnds === 2) threats.openFour++;
          else if (result.count === 4 && result.openEnds === 1) threats.four++;
          else if (result.count === 3 && result.openEnds === 2) threats.openThree++;
          else if (result.count === 3 && result.openEnds === 1) threats.three++;
        }
        board[y][x] = EMPTY;
        return threats;
      }

      function quickEvaluate(x, y, player) {
        let score = 0;
        const enemy = -player;
        const myThreats = analyzeThreats(x, y, player);
        const enemyThreats = analyzeThreats(x, y, enemy);
        
        // Âç≥Âãù„Å°
        if (myThreats.five > 0) return 100000000;
        
        // Áõ∏Êâã„ÅÆÂç≥Âãù„Å°„ÇíÈò≤„Åê
        if (enemyThreats.five > 0) return 90000000;
        
        // Ëá™ÂàÜ„ÅÆÈñãÊîæÂõõÔºà„Åª„ÅºÂãù„Å°Á¢∫ÂÆöÔºâ
        if (myThreats.openFour > 0) return 80000000;
        
        // Áõ∏Êâã„ÅÆÈñãÊîæÂõõ„ÇíÈò≤„Åê
        if (enemyThreats.openFour > 0) return 70000000;
        
        // Ëá™ÂàÜ„ÅÆÂõõ‰∏âÔºàÂãù„Å°Á¢∫ÂÆö„Ç≥„É≥„ÉúÔºâ
        if (myThreats.four > 0 && myThreats.openThree > 0) return 60000000;
        
        // Ëá™ÂàÜ„ÅÆÂèåÂõõÔºàÂãù„Å°Á¢∫ÂÆö„Ç≥„É≥„ÉúÔºâ
        if (myThreats.four >= 2) return 55000000;
        
        // Áõ∏Êâã„ÅÆÂõõ‰∏â„ÇíÈò≤„Åê
        if (enemyThreats.four > 0 && enemyThreats.openThree > 0) return 50000000;
        
        // Áõ∏Êâã„ÅÆÂèåÂõõ„ÇíÈò≤„Åê
        if (enemyThreats.four >= 2) return 45000000;
        
        // Ëá™ÂàÜ„ÅÆÂèå‰∏âÔºàÂº∑„ÅÑÊîª„ÇÅÔºâ
        if (myThreats.openThree >= 2) return 40000000;
        
        // Áõ∏Êâã„ÅÆÂèå‰∏â„ÇíÈò≤„Åê
        if (enemyThreats.openThree >= 2) return 35000000;
        
        // ÈÄöÂ∏∏„ÅÆË©ï‰æ°
        if (myThreats.four > 0) score += 500000;
        if (myThreats.openThree > 0) score += 50000;
        if (myThreats.three > 0) score += 5000;
        
        if (enemyThreats.four > 0) score += 400000;
        if (enemyThreats.openThree > 0) score += 40000;
        if (enemyThreats.three > 0) score += 4000;
        
        // ‰∏≠Â§Æ„Éú„Éº„Éä„Çπ
        const dist = Math.abs(x - 7) + Math.abs(y - 7);
        score += (14 - dist) * 100;
        
        return score;
      }

      function alphaBeta(depth, alpha, beta, isMaximizing, aiPlayer, config, candidates) {
        if (depth === 0) {
          let score = evaluateBoard(aiPlayer);
          score *= isMaximizing ? config.attackMult : config.defenseMult;
          return { score, move: null };
        }

        const currentPlayer = isMaximizing ? aiPlayer : -aiPlayer;

        // Âç≥Â∫ß„ÅÆÂãùÊïó„ÉÅ„Çß„ÉÉ„ÇØ
        for (const { x, y } of candidates) {
          board[y][x] = currentPlayer;
          const win = checkWin(x, y, currentPlayer);
          board[y][x] = EMPTY;
          if (win) {
            const winScore = PATTERN_SCORES.FIVE * (depth + 1);
            return { score: isMaximizing ? winScore : -winScore, move: { x, y } };
          }
        }

        let bestMove = candidates[0];

        if (isMaximizing) {
          let maxScore = -Infinity;
          for (const { x, y } of candidates) {
            board[y][x] = currentPlayer;
            const childCandidates = generateChildCandidates(x, y, candidates);
            const result = alphaBeta(depth - 1, alpha, beta, false, aiPlayer, config, childCandidates);
            board[y][x] = EMPTY;
            if (result.score > maxScore) {
              maxScore = result.score;
              bestMove = { x, y };
            }
            alpha = Math.max(alpha, result.score);
            if (beta <= alpha) break;
          }
          return { score: maxScore, move: bestMove };
        } else {
          let minScore = Infinity;
          for (const { x, y } of candidates) {
            board[y][x] = currentPlayer;
            const childCandidates = generateChildCandidates(x, y, candidates);
            const result = alphaBeta(depth - 1, alpha, beta, true, aiPlayer, config, childCandidates);
            board[y][x] = EMPTY;
            if (result.score < minScore) {
              minScore = result.score;
              bestMove = { x, y };
            }
            beta = Math.min(beta, result.score);
            if (beta <= alpha) break;
          }
          return { score: minScore, move: bestMove };
        }
      }

      function generateChildCandidates(lastX, lastY, parentCandidates) {
        const candidateSet = new Set();
        const newCandidates = [];

        // Êñ∞„Åó„ÅÑÊâã„ÅÆÂë®Âõ≤„ÇíËøΩÂä†
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const ny = lastY + dy, nx = lastX + dx;
            if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE && board[ny][nx] === EMPTY) {
              const key = nx + ',' + ny;
              if (!candidateSet.has(key)) {
                candidateSet.add(key);
                newCandidates.push({ x: nx, y: ny, priority: quickEvaluate(nx, ny, WHITE) });
              }
            }
          }
        }

        // Ë¶™„ÅÆÂÄôË£ú„ÇÇ„Éû„Éº„Ç∏ÔºàÊâì„Å£„ÅüÊâã‰ª•Â§ñÔºâ
        for (const c of parentCandidates) {
          if (board[c.y][c.x] === EMPTY) {
            const key = c.x + ',' + c.y;
            if (!candidateSet.has(key)) {
              candidateSet.add(key);
              newCandidates.push(c);
            }
          }
        }

        newCandidates.sort((a, b) => b.priority - a.priority);
        return newCandidates.slice(0, 15);
      }

      // „É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø°
      self.onmessage = function(e) {
        const { candidates, boardData, aiPlayer, aiType, workerId, zobristSeed } = e.data;
        
        // ÂàùÊúüÂåñ
        board = boardData.map(row => [...row]);
        initZobrist(zobristSeed);
        transpositionTable.clear();

        const config = AI_CONFIG[aiType];
        let bestMove = null;
        let bestScore = -Infinity;

        // ÊãÖÂΩì„Åô„ÇãÂÄôË£úÊâã„ÇíÊé¢Á¥¢
        for (const candidate of candidates) {
          board[candidate.y][candidate.x] = aiPlayer;
          
          // „Åì„ÅÆÊâã„ÇíÊâì„Å£„ÅüÂæå„ÅÆÂ≠êÂÄôË£ú„ÇíÁîüÊàê
          const childCandidates = generateChildCandidates(candidate.x, candidate.y, candidates);
          
          const result = alphaBeta(
            config.depth - 1,
            -Infinity,
            Infinity,
            false,
            aiPlayer,
            config,
            childCandidates
          );
          
          board[candidate.y][candidate.x] = EMPTY;

          const score = result.score;
          if (score > bestScore) {
            bestScore = score;
            bestMove = { x: candidate.x, y: candidate.y };
          }
        }

        self.postMessage({ workerId, bestMove, bestScore });
      };
    `;

    // ========================================
    // Game Constants
    // ========================================
    const BOARD_SIZE = 15;
    const EMPTY = 0;
    const BLACK = 1;
    const WHITE = -1;
    const NUM_WORKERS = 4;

    // ========================================
    // Game State
    // ========================================
    let board = [];
    let currentPlayer = BLACK;
    let gameOver = false;
    let moveHistory = [];
    let scores = { black: 0, white: 0 };
    let gameMode = 'pvp';
    let aiType = 'aggressive';
    let isAiThinking = false;
    
    let blackAiType = 'aggressive';
    let whiteAiType = 'ultimate';
    let battleRunning = false;
    let battlePaused = false;
    let battleTimeoutId = null;

    // Workers
    let workers = [];
    let workerResults = [];
    let pendingWorkers = 0;
    let currentAiResolve = null;
    const zobristSeed = 12345; // ÂÖ®Worker„ÅßÂêå„Åò„Ç∑„Éº„Éâ

    // ========================================
    // Worker Setup
    // ========================================
    function initWorkers() {
      // Êó¢Â≠ò„ÅÆ„ÉØ„Éº„Ç´„Éº„ÇíÁµÇ‰∫Ü
      workers.forEach(w => w.terminate());
      workers = [];

      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);

      for (let i = 0; i < NUM_WORKERS; i++) {
        const worker = new Worker(url);
        worker.onmessage = handleWorkerMessage;
        workers.push(worker);
      }
    }

    function handleWorkerMessage(e) {
      const { workerId, bestMove, bestScore } = e.data;
      
      workerResults.push({ workerId, bestMove, bestScore });
      document.getElementById('worker' + workerId).classList.remove('active');
      pendingWorkers--;

      if (pendingWorkers === 0 && currentAiResolve) {
        // ÂÖ®Worker„ÅÆÁµêÊûú„Åã„ÇâÊúÄÂñÑÊâã„ÇíÈÅ∏Êäû
        let best = workerResults[0];
        for (const result of workerResults) {
          if (result.bestScore > best.bestScore) {
            best = result;
          }
        }
        currentAiResolve(best.bestMove);
        currentAiResolve = null;
      }
    }

    function setWorkerActive(id, active) {
      const el = document.getElementById('worker' + id);
      if (active) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    }

    // ========================================
    // Canvas Setup
    // ========================================
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    let cellSize, padding, boardPixelSize;

    function initCanvas() {
      const maxSize = Math.min(window.innerWidth - 32, 500);
      boardPixelSize = maxSize;
      canvas.width = boardPixelSize;
      canvas.height = boardPixelSize;
      padding = boardPixelSize * 0.04;
      cellSize = (boardPixelSize - padding * 2) / (BOARD_SIZE - 1);
    }

    // ========================================
    // Board Rendering
    // ========================================
    function drawBoard() {
      ctx.fillStyle = '#dcb35c';
      ctx.fillRect(0, 0, boardPixelSize, boardPixelSize);

      ctx.strokeStyle = '#8b7355';
      ctx.lineWidth = 1;

      for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = padding + i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, padding);
        ctx.lineTo(pos, boardPixelSize - padding);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(padding, pos);
        ctx.lineTo(boardPixelSize - padding, pos);
        ctx.stroke();
      }

      const starPoints = [
        [3, 3], [3, 7], [3, 11],
        [7, 3], [7, 7], [7, 11],
        [11, 3], [11, 7], [11, 11]
      ];

      ctx.fillStyle = '#8b7355';
      starPoints.forEach(([x, y]) => {
        const px = padding + x * cellSize;
        const py = padding + y * cellSize;
        ctx.beginPath();
        ctx.arc(px, py, cellSize * 0.12, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawStones() {
      const lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            drawStone(x, y, board[y][x], lastMove && lastMove.x === x && lastMove.y === y);
          }
        }
      }
    }

    function drawStone(x, y, player, isLast = false) {
      const px = padding + x * cellSize;
      const py = padding + y * cellSize;
      const radius = cellSize * 0.43;

      ctx.beginPath();
      ctx.arc(px + 2, py + 2, radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fill();

      const gradient = ctx.createRadialGradient(
        px - radius * 0.3, py - radius * 0.3, radius * 0.1,
        px, py, radius
      );

      if (player === BLACK) {
        gradient.addColorStop(0, '#4a4a4a');
        gradient.addColorStop(1, '#1a1a1a');
      } else {
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(1, '#cccccc');
      }

      ctx.beginPath();
      ctx.arc(px, py, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      if (isLast) {
        ctx.beginPath();
        ctx.arc(px, py, radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = player === BLACK ? '#ff6b6b' : '#e74c3c';
        ctx.fill();
      }
    }

    function render() {
      drawBoard();
      drawStones();
    }

    // ========================================
    // Game Logic
    // ========================================
    function initBoard() {
      board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
      currentPlayer = BLACK;
      gameOver = false;
      moveHistory = [];
      isAiThinking = false;
      updateStatus();
      render();
    }

    function isValidMove(x, y) {
      return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[y][x] === EMPTY;
    }

    function makeMove(x, y) {
      if (!isValidMove(x, y) || gameOver || isAiThinking) return false;

      board[y][x] = currentPlayer;
      moveHistory.push({ x, y, player: currentPlayer });

      if (checkWin(x, y, currentPlayer)) {
        gameOver = true;
        render();
        showWinner(currentPlayer);
        return true;
      }

      if (checkDraw()) {
        gameOver = true;
        render();
        showDraw();
        return true;
      }

      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
      updateStatus();
      render();

      if (gameMode === 'ai' && currentPlayer === WHITE && !gameOver) {
        triggerAiMove();
      }

      return true;
    }

    function undoMove() {
      if (moveHistory.length === 0 || gameOver || isAiThinking) return;

      const undoCount = gameMode === 'ai' && moveHistory.length >= 2 ? 2 : 1;
      
      for (let i = 0; i < undoCount && moveHistory.length > 0; i++) {
        const lastMove = moveHistory.pop();
        board[lastMove.y][lastMove.x] = EMPTY;
      }

      currentPlayer = moveHistory.length % 2 === 0 ? BLACK : WHITE;
      updateStatus();
      render();
    }

    const DIRECTIONS = [[1, 0], [0, 1], [1, 1], [1, -1]];

    function checkWin(x, y, player) {
      for (const [dx, dy] of DIRECTIONS) {
        let count = 1;
        for (let i = 1; i < 5; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }
        for (let i = 1; i < 5; i++) {
          const nx = x - dx * i, ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }
        if (count >= 5) return true;
      }
      return false;
    }

    function checkDraw() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === EMPTY) return false;
        }
      }
      return true;
    }

    // ========================================
    // AI with Parallel Workers
    // ========================================
    function generateCandidates() {
      if (moveHistory.length === 0) {
        return [{ x: 7, y: 7, priority: 1000000 }];
      }

      const candidateMap = new Map();
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            for (let dy = -2; dy <= 2; dy++) {
              for (let dx = -2; dx <= 2; dx++) {
                const ny = y + dy, nx = x + dx;
                if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE && board[ny][nx] === EMPTY) {
                  const key = `${nx},${ny}`;
                  if (!candidateMap.has(key)) {
                    const priority = quickEvaluate(nx, ny);
                    candidateMap.set(key, { x: nx, y: ny, priority });
                  }
                }
              }
            }
          }
        }
      }

      const candidates = Array.from(candidateMap.values());
      candidates.sort((a, b) => b.priority - a.priority);
      return candidates.slice(0, 24);
    }

    function quickEvaluate(x, y, player = WHITE) {
      let score = 0;
      
      // Âç≥Âãù„Å°/Âç≥Ë≤†„Åë„ÉÅ„Çß„ÉÉ„ÇØ
      board[y][x] = player;
      if (checkWin(x, y, player)) { board[y][x] = EMPTY; return 100000000; }
      board[y][x] = -player;
      if (checkWin(x, y, -player)) { board[y][x] = EMPTY; return 90000000; }
      board[y][x] = EMPTY;

      // ‰∏≠Â§Æ„Éú„Éº„Éä„Çπ
      const dist = Math.abs(x - 7) + Math.abs(y - 7);
      score += (14 - dist) * 50;
      
      return score;
    }

    function findEmergencyMove(player) {
      const enemy = -player;
      const candidates = generateCandidates();

      // Âç≥Âãù„Å°
      for (const { x, y } of candidates) {
        board[y][x] = player;
        const win = checkWin(x, y, player);
        board[y][x] = EMPTY;
        if (win) return { x, y };
      }

      // Âç≥Ë≤†„ÅëÈò≤Ê≠¢
      for (const { x, y } of candidates) {
        board[y][x] = enemy;
        const lose = checkWin(x, y, enemy);
        board[y][x] = EMPTY;
        if (lose) return { x, y };
      }

      return null;
    }

    async function calculateAiMoveParallel(type, player) {
      // ÂàùÊâã„Éª2ÊâãÁõÆ
      if (moveHistory.length === 0) {
        return { x: 7, y: 7 };
      }
      if (moveHistory.length === 1) {
        const first = moveHistory[0];
        const offsets = [[1, 1], [-1, -1], [1, -1], [-1, 1], [1, 0], [0, 1]];
        for (const [dx, dy] of offsets) {
          const nx = first.x + dx, ny = first.y + dy;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === EMPTY) {
            return { x: nx, y: ny };
          }
        }
      }

      // Á∑äÊÄ•Êâã„ÉÅ„Çß„ÉÉ„ÇØ
      const emergency = findEmergencyMove(player);
      if (emergency) return emergency;

      // ÂÄôË£úÊâã„ÇíÁîüÊàê
      const candidates = generateCandidates();
      if (candidates.length === 0) return null;
      if (candidates.length === 1) return candidates[0];

      // ÂÄôË£ú„ÇíWorker„Å´ÂàÜÈÖç
      const chunkSize = Math.ceil(candidates.length / NUM_WORKERS);
      workerResults = [];
      pendingWorkers = NUM_WORKERS;

      return new Promise((resolve) => {
        currentAiResolve = resolve;

        for (let i = 0; i < NUM_WORKERS; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, candidates.length);
          const chunk = candidates.slice(start, end);

          if (chunk.length === 0) {
            pendingWorkers--;
            if (pendingWorkers === 0) {
              let best = workerResults[0];
              for (const r of workerResults) {
                if (r.bestScore > best.bestScore) best = r;
              }
              resolve(best.bestMove);
            }
            continue;
          }

          setWorkerActive(i, true);
          workers[i].postMessage({
            candidates: chunk,
            boardData: board.map(row => [...row]),
            aiPlayer: player,
            aiType: type,
            workerId: i,
            zobristSeed: zobristSeed
          });
        }
      });
    }

    async function triggerAiMove() {
      isAiThinking = true;
      updateStatus();

      let move;
      if (aiType === 'ultimate') {
        // ÊúÄÂº∑„ÅÆ„ÅøWorker‰∏¶Âàó
        move = await calculateAiMoveParallel(aiType, WHITE);
      } else {
        // ‰ªñ„ÅØ„É°„Ç§„É≥„Çπ„É¨„ÉÉ„Éâ„ÅßË®àÁÆó
        move = calculateAiMoveSimple(aiType, WHITE);
      }
      
      isAiThinking = false;
      if (move && !gameOver) {
        makeMove(move.x, move.y);
      }
    }

    // ÊúÄÂº∑‰ª•Â§ñÁî®„ÅÆ„Ç∑„É≥„Éó„É´„Å™AIÔºà„É°„Ç§„É≥„Çπ„É¨„ÉÉ„ÉâÔºâ
    function calculateAiMoveSimple(type, player) {
      if (moveHistory.length === 0) {
        return { x: 7, y: 7 };
      }
      if (moveHistory.length === 1) {
        const first = moveHistory[0];
        const offsets = [[1, 1], [-1, -1], [1, -1], [-1, 1], [1, 0], [0, 1]];
        for (const [dx, dy] of offsets) {
          const nx = first.x + dx, ny = first.y + dy;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === EMPTY) {
            return { x: nx, y: ny };
          }
        }
      }

      const emergency = findEmergencyMove(player);
      if (emergency) return emergency;

      const candidates = generateCandidates();
      if (candidates.length === 0) return null;
      
      // ‰∏ÄÁï™ÂÑ™ÂÖàÂ∫¶„ÅÆÈ´ò„ÅÑÊâã„ÇíËøî„Åô
      return candidates[0];
    }

    // ========================================
    // AI vs AI Battle
    // ========================================
    function startBattle() {
      if (gameOver) initBoard();
      battleRunning = true;
      battlePaused = false;
      updateBattleButtons();
      runBattle();
    }

    function pauseBattle() {
      battlePaused = !battlePaused;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? '‚ñ∂Ô∏è ÂÜçÈñã' : '‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢';
      if (!battlePaused && battleRunning) runBattle();
    }

    function stopBattle() {
      battleRunning = false;
      battlePaused = false;
      if (battleTimeoutId) {
        clearTimeout(battleTimeoutId);
        battleTimeoutId = null;
      }
      isAiThinking = false;
      updateBattleButtons();
      updateStatus();
    }

    function updateBattleButtons() {
      document.getElementById('startBattleBtn').disabled = battleRunning && !battlePaused;
      document.getElementById('pauseBattleBtn').disabled = !battleRunning;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? '‚ñ∂Ô∏è ÂÜçÈñã' : '‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢';
    }

    async function runBattle() {
      if (!battleRunning || battlePaused || gameOver) return;

      isAiThinking = true;
      updateStatus();

      const currentAiType = currentPlayer === BLACK ? blackAiType : whiteAiType;
      
      let move;
      if (currentAiType === 'ultimate') {
        // ÊúÄÂº∑„ÅÆ„ÅøWorker‰∏¶Âàó
        move = await calculateAiMoveParallel(currentAiType, currentPlayer);
      } else {
        // ‰ªñ„ÅØ„É°„Ç§„É≥„Çπ„É¨„ÉÉ„Éâ„ÅßË®àÁÆó
        move = calculateAiMoveSimple(currentAiType, currentPlayer);
      }

      isAiThinking = false;

      if (move && !gameOver && battleRunning && !battlePaused) {
        makeMove(move.x, move.y);

        if (!gameOver && battleRunning && !battlePaused) {
          const speed = parseInt(document.getElementById('battleSpeed').value);
          battleTimeoutId = setTimeout(runBattle, speed);
        }
      }
    }

    // ========================================
    // UI Updates
    // ========================================
    function updateStatus() {
      const status = document.getElementById('status');
      if (gameOver) {
        status.textContent = '„Ç≤„Éº„É†ÁµÇ‰∫Ü';
      } else if (isAiThinking) {
        if (gameMode === 'aivai') {
          const aiName = currentPlayer === BLACK ? getAiName(blackAiType) : getAiName(whiteAiType);
          status.textContent = `${currentPlayer === BLACK ? '‚ö´' : '‚ö™'} ${aiName} ÊÄùËÄÉ‰∏≠...`;
        } else {
          status.textContent = `${getAiName(aiType)} ÊÄùËÄÉ‰∏≠...`;
        }
      } else {
        if (gameMode === 'aivai') {
          const aiName = currentPlayer === BLACK ? getAiName(blackAiType) : getAiName(whiteAiType);
          status.textContent = `${currentPlayer === BLACK ? '‚ö´' : '‚ö™'} ${aiName} „ÅÆÁï™`;
        } else {
          status.textContent = currentPlayer === BLACK ? 'Èªí„ÅÆÁï™„Åß„Åô' : 'ÁôΩ„ÅÆÁï™„Åß„Åô';
        }
      }
    }

    function getAiName(type) {
      switch (type) {
        case 'aggressive': return 'üî•ÊîªÊíÉÂûã';
        case 'defensive': return 'üõ°Ô∏èÈò≤Âæ°Âûã';
        case 'strategic': return '‚öñÔ∏è„Éê„É©„É≥„ÇπÂûã';
        case 'ultimate': return 'üëπÊúÄÂº∑';
        default: return type;
      }
    }

    function showWinner(player) {
      const overlay = document.getElementById('winnerOverlay');
      const stone = document.getElementById('winnerStone');
      const text = document.getElementById('winnerText');

      stone.className = 'stone-icon ' + (player === BLACK ? 'black' : 'white');
      
      if (gameMode === 'aivai') {
        const winnerAi = player === BLACK ? getAiName(blackAiType) : getAiName(whiteAiType);
        text.textContent = `${winnerAi} „ÅÆÂãù„Å°ÔºÅ`;
      } else if (gameMode === 'ai') {
        text.textContent = player === BLACK ? '„ÅÇ„Å™„Åü„ÅÆÂãù„Å°ÔºÅ' : 'AI„ÅÆÂãù„Å°ÔºÅ';
      } else {
        text.textContent = player === BLACK ? 'Èªí„ÅÆÂãù„Å°ÔºÅ' : 'ÁôΩ„ÅÆÂãù„Å°ÔºÅ';
      }

      if (player === BLACK) scores.black++;
      else scores.white++;
      updateScores();

      if (gameMode === 'aivai') stopBattle();

      overlay.classList.add('visible');
    }

    function showDraw() {
      const overlay = document.getElementById('winnerOverlay');
      const stone = document.getElementById('winnerStone');
      const text = document.getElementById('winnerText');

      stone.className = 'stone-icon';
      stone.style.background = 'linear-gradient(90deg, #1a1a1a 50%, #fff 50%)';
      text.textContent = 'Âºï„ÅçÂàÜ„ÅëÔºÅ';

      overlay.classList.add('visible');
    }

    function updateScores() {
      document.getElementById('blackScore').textContent = scores.black;
      document.getElementById('whiteScore').textContent = scores.white;
    }

    // ========================================
    // Event Handlers
    // ========================================
    function getGridPosition(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const gridX = Math.round((x - padding) / cellSize);
      const gridY = Math.round((y - padding) / cellSize);
      return { x: gridX, y: gridY };
    }

    canvas.addEventListener('click', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer === WHITE) return;
      if (gameMode === 'aivai') return;

      const pos = getGridPosition(e.clientX, e.clientY);
      makeMove(pos.x, pos.y);
    });

    canvas.addEventListener('touchend', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer === WHITE) return;
      if (gameMode === 'aivai') return;

      e.preventDefault();
      const touch = e.changedTouches[0];
      const pos = getGridPosition(touch.clientX, touch.clientY);
      makeMove(pos.x, pos.y);
    });

    // Mode buttons
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        
        document.getElementById('aiTypes').classList.toggle('visible', gameMode === 'ai');
        document.getElementById('aiVsAiSelector').classList.toggle('visible', gameMode === 'aivai');
        document.getElementById('battleControls').classList.toggle('visible', gameMode === 'aivai');
        document.getElementById('workerStatus').style.display = gameMode === 'pvp' ? 'none' : 'flex';
        
        stopBattle();
        initBoard();
      });
    });

    // AI type buttons
    document.querySelectorAll('.ai-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ai-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiType = btn.dataset.ai;
        initBoard();
      });
    });

    // AI vs AI selector buttons
    document.querySelectorAll('#blackAiButtons .ai-select-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#blackAiButtons .ai-select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        blackAiType = btn.dataset.ai;
      });
    });

    document.querySelectorAll('#whiteAiButtons .ai-select-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#whiteAiButtons .ai-select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        whiteAiType = btn.dataset.ai;
      });
    });

    // Battle control buttons
    document.getElementById('startBattleBtn').addEventListener('click', startBattle);
    document.getElementById('pauseBattleBtn').addEventListener('click', pauseBattle);
    document.getElementById('stopBattleBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });

    // Control buttons
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('resetBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      document.getElementById('winnerOverlay').classList.remove('visible');
      initBoard();
    });

    // Window resize
    window.addEventListener('resize', () => {
      initCanvas();
      render();
    });

    // ========================================
    // Initialize
    // ========================================
    document.getElementById('workerStatus').style.display = 'none';
    initWorkers();
    initCanvas();
    initBoard();
  </script>
</body>
</html>
