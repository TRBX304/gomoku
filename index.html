<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>äº”ç›®ä¸¦ã¹</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      color: #fff;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 12px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .mode-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #2d3748;
      color: #fff;
    }

    .mode-btn:hover {
      transform: translateY(-2px);
    }

    .mode-btn.active {
      background: #4299e1;
      box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
    }

    .ai-types {
      display: none;
      gap: 6px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .ai-types.visible {
      display: flex;
    }

    .ai-btn {
      padding: 8px 16px;
      border: 2px solid transparent;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      color: #fff;
    }

    .ai-btn.aggressive {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
    }

    .ai-btn.aggressive.active {
      background: #ef4444;
    }

    .ai-btn.defensive {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
    }

    .ai-btn.defensive.active {
      background: #3b82f6;
    }

    .ai-btn.strategic {
      background: rgba(34, 197, 94, 0.2);
      border-color: #22c55e;
    }

    .ai-btn.strategic.active {
      background: #22c55e;
    }

    .ai-btn.ultimate {
      background: rgba(168, 85, 247, 0.2);
      border-color: #a855f7;
    }

    .ai-btn.ultimate.active {
      background: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
      animation: ultimatePulse 2s infinite;
    }

    @keyframes ultimatePulse {
      0%, 100% { box-shadow: 0 0 5px #a855f7; }
      50% { box-shadow: 0 0 20px #a855f7, 0 0 30px #6366f1; }
    }

    .ai-vs-ai-selector {
      display: none;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .ai-vs-ai-selector.visible {
      display: flex;
    }

    .ai-select-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .ai-select-group label {
      font-size: 0.85rem;
      font-weight: 600;
    }

    .ai-select-buttons {
      display: flex;
      gap: 4px;
    }

    .ai-select-btn {
      width: 40px;
      height: 40px;
      border: 2px solid #4a5568;
      border-radius: 8px;
      background: rgba(255,255,255,0.1);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .ai-select-btn:hover {
      transform: scale(1.1);
    }

    .ai-select-btn.aggressive.active { border-color: #ef4444; background: rgba(239,68,68,0.3); }
    .ai-select-btn.defensive.active { border-color: #3b82f6; background: rgba(59,130,246,0.3); }
    .ai-select-btn.strategic.active { border-color: #22c55e; background: rgba(34,197,94,0.3); }
    .ai-select-btn.ultimate.active { border-color: #a855f7; background: rgba(168,85,247,0.3); }

    .vs-label {
      font-size: 1.5rem;
      font-weight: bold;
      color: #f59e0b;
    }

    .battle-controls {
      display: none;
      gap: 8px;
      margin-bottom: 12px;
    }

    .battle-controls.visible {
      display: flex;
    }

    .battle-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .battle-btn.start {
      background: #22c55e;
      color: #fff;
    }

    .battle-btn.pause {
      background: #f59e0b;
      color: #fff;
    }

    .battle-btn.stop {
      background: #ef4444;
      color: #fff;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.85rem;
    }

    .speed-control input {
      width: 80px;
    }

    .status {
      font-size: 1.1rem;
      margin-bottom: 12px;
      padding: 8px 20px;
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .board-container {
      position: relative;
      touch-action: none;
    }

    canvas {
      display: block;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .ctrl-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #4a5568;
      color: #fff;
    }

    .ctrl-btn:hover {
      background: #5a6578;
      transform: translateY(-2px);
    }

    .ctrl-btn:active {
      transform: translateY(0);
    }

    .ctrl-btn.primary {
      background: #48bb78;
    }

    .ctrl-btn.primary:hover {
      background: #38a169;
    }

    .score-board {
      display: flex;
      gap: 24px;
      margin-bottom: 12px;
      font-size: 1rem;
    }

    .score {
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
    }

    .score.black {
      border-left: 4px solid #1a1a1a;
    }

    .score.white {
      border-left: 4px solid #fff;
    }

    .winner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .winner-overlay.visible {
      display: flex;
    }

    .winner-modal {
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      padding: 32px 48px;
      border-radius: 16px;
      text-align: center;
      animation: popIn 0.3s ease-out;
    }

    @keyframes popIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .winner-modal h2 {
      font-size: 2rem;
      margin-bottom: 16px;
    }

    .winner-modal .stone-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      margin: 0 auto 16px;
    }

    .winner-modal .stone-icon.black {
      background: radial-gradient(circle at 30% 30%, #4a4a4a, #1a1a1a);
    }

    .winner-modal .stone-icon.white {
      background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    }

    .winner-modal button {
      margin-top: 16px;
      padding: 12px 32px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      background: #4299e1;
      color: #fff;
      transition: all 0.2s;
    }

    .winner-modal button:hover {
      background: #3182ce;
    }
  </style>
</head>
<body>
  <h1>ğŸ¯ äº”ç›®ä¸¦ã¹</h1>

  <div class="mode-selector">
    <button class="mode-btn active" data-mode="pvp">ğŸ‘¥ äºŒäººãƒ—ãƒ¬ã‚¤</button>
    <button class="mode-btn" data-mode="ai">ğŸ¤– AIå¯¾æˆ¦</button>
    <button class="mode-btn" data-mode="aivai">ğŸ¤–âš”ï¸ğŸ¤– AIåŒå£«</button>
  </div>

  <div class="ai-types" id="aiTypes">
    <button class="ai-btn aggressive active" data-ai="aggressive">ğŸ”¥ æ”»æ’ƒå‹</button>
    <button class="ai-btn defensive" data-ai="defensive">ğŸ›¡ï¸ é˜²å¾¡å‹</button>
    <button class="ai-btn strategic" data-ai="strategic">âš–ï¸ ãƒãƒ©ãƒ³ã‚¹å‹</button>
    <button class="ai-btn ultimate" data-ai="ultimate">ğŸ‘¹ æœ€å¼·</button>
  </div>

  <div class="ai-vs-ai-selector" id="aiVsAiSelector">
    <div class="ai-select-group">
      <label>âš« é»’AI</label>
      <div class="ai-select-buttons" id="blackAiButtons">
        <button class="ai-select-btn aggressive active" data-ai="aggressive">ğŸ”¥</button>
        <button class="ai-select-btn defensive" data-ai="defensive">ğŸ›¡ï¸</button>
        <button class="ai-select-btn strategic" data-ai="strategic">âš–ï¸</button>
        <button class="ai-select-btn ultimate" data-ai="ultimate">ğŸ‘¹</button>
      </div>
    </div>
    <div class="vs-label">VS</div>
    <div class="ai-select-group">
      <label>âšª ç™½AI</label>
      <div class="ai-select-buttons" id="whiteAiButtons">
        <button class="ai-select-btn aggressive" data-ai="aggressive">ğŸ”¥</button>
        <button class="ai-select-btn defensive" data-ai="defensive">ğŸ›¡ï¸</button>
        <button class="ai-select-btn strategic" data-ai="strategic">âš–ï¸</button>
        <button class="ai-select-btn ultimate active" data-ai="ultimate">ğŸ‘¹</button>
      </div>
    </div>
  </div>

  <div class="score-board">
    <div class="score black">âš« é»’: <span id="blackScore">0</span></div>
    <div class="score white">âšª ç™½: <span id="whiteScore">0</span></div>
  </div>

  <div class="status" id="status">é»’ã®ç•ªã§ã™</div>

  <div class="battle-controls" id="battleControls">
    <button class="battle-btn start" id="startBattleBtn">â–¶ï¸ é–‹å§‹</button>
    <button class="battle-btn pause" id="pauseBattleBtn">â¸ï¸ ä¸€æ™‚åœæ­¢</button>
    <button class="battle-btn stop" id="stopBattleBtn">â¹ï¸ åœæ­¢</button>
    <div class="speed-control">
      <label>é€Ÿåº¦:</label>
      <input type="range" id="battleSpeed" min="100" max="2000" value="800">
    </div>
  </div>

  <div class="board-container">
    <canvas id="board"></canvas>
  </div>

  <div class="controls">
    <button class="ctrl-btn" id="undoBtn">â†©ï¸ å¾…ã£ãŸ</button>
    <button class="ctrl-btn primary" id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>

  <div class="winner-overlay" id="winnerOverlay">
    <div class="winner-modal">
      <div class="stone-icon" id="winnerStone"></div>
      <h2 id="winnerText">é»’ã®å‹ã¡ï¼</h2>
      <button id="playAgainBtn">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
    </div>
  </div>

  <script>
    // ========================================
    // Game Constants
    // ========================================
    const BOARD_SIZE = 15;
    const EMPTY = 0;
    const BLACK = 1;  // äººé–“ï¼ˆå…ˆæ‰‹ï¼‰
    const WHITE = -1; // å¯¾æˆ¦ç›¸æ‰‹ï¼ˆå¾Œæ‰‹ï¼‰

    // ========================================
    // Game State
    // ========================================
    let board = [];
    let currentPlayer = BLACK;
    let gameOver = false;
    let moveHistory = [];
    let scores = { black: 0, white: 0 };
    let gameMode = 'pvp'; // 'pvp', 'ai', or 'aivai'
    let aiType = 'aggressive';
    let isAiThinking = false;
    
    // AI vs AI ãƒ¢ãƒ¼ãƒ‰ç”¨
    let blackAiType = 'aggressive';
    let whiteAiType = 'ultimate';
    let battleRunning = false;
    let battlePaused = false;
    let battleTimeoutId = null;

    // ========================================
    // Canvas Setup
    // ========================================
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    let cellSize, padding, boardPixelSize;

    function initCanvas() {
      const maxSize = Math.min(window.innerWidth - 32, 500);
      boardPixelSize = maxSize;
      canvas.width = boardPixelSize;
      canvas.height = boardPixelSize;
      padding = boardPixelSize * 0.04;
      cellSize = (boardPixelSize - padding * 2) / (BOARD_SIZE - 1);
    }

    // ========================================
    // Board Rendering
    // ========================================
    function drawBoard() {
      // Background
      ctx.fillStyle = '#dcb35c';
      ctx.fillRect(0, 0, boardPixelSize, boardPixelSize);

      // Grid lines
      ctx.strokeStyle = '#8b7355';
      ctx.lineWidth = 1;

      for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = padding + i * cellSize;
        
        // Vertical
        ctx.beginPath();
        ctx.moveTo(pos, padding);
        ctx.lineTo(pos, boardPixelSize - padding);
        ctx.stroke();

        // Horizontal
        ctx.beginPath();
        ctx.moveTo(padding, pos);
        ctx.lineTo(boardPixelSize - padding, pos);
        ctx.stroke();
      }

      // Star points (å¤©å…ƒã¨æ˜Ÿ)
      const starPoints = [
        [3, 3], [3, 7], [3, 11],
        [7, 3], [7, 7], [7, 11],
        [11, 3], [11, 7], [11, 11]
      ];

      ctx.fillStyle = '#8b7355';
      starPoints.forEach(([x, y]) => {
        const px = padding + x * cellSize;
        const py = padding + y * cellSize;
        ctx.beginPath();
        ctx.arc(px, py, cellSize * 0.12, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawStones() {
      const lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;

      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            drawStone(x, y, board[y][x], lastMove && lastMove.x === x && lastMove.y === y);
          }
        }
      }
    }

    function drawStone(x, y, player, isLast = false) {
      const px = padding + x * cellSize;
      const py = padding + y * cellSize;
      const radius = cellSize * 0.43;

      // Shadow
      ctx.beginPath();
      ctx.arc(px + 2, py + 2, radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fill();

      // Stone
      const gradient = ctx.createRadialGradient(
        px - radius * 0.3, py - radius * 0.3, radius * 0.1,
        px, py, radius
      );

      if (player === BLACK) {
        gradient.addColorStop(0, '#4a4a4a');
        gradient.addColorStop(1, '#1a1a1a');
      } else {
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(1, '#cccccc');
      }

      ctx.beginPath();
      ctx.arc(px, py, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      // Last move marker
      if (isLast) {
        ctx.beginPath();
        ctx.arc(px, py, radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = player === BLACK ? '#ff6b6b' : '#e74c3c';
        ctx.fill();
      }
    }

    function render() {
      drawBoard();
      drawStones();
    }

    // ========================================
    // Game Logic
    // ========================================
    function initBoard() {
      board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
      currentPlayer = BLACK;
      gameOver = false;
      moveHistory = [];
      isAiThinking = false;
      updateStatus();
      render();
    }

    function isValidMove(x, y) {
      return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[y][x] === EMPTY;
    }

    function makeMove(x, y) {
      if (!isValidMove(x, y) || gameOver || isAiThinking) return false;

      board[y][x] = currentPlayer;
      moveHistory.push({ x, y, player: currentPlayer });

      if (checkWin(x, y, currentPlayer)) {
        gameOver = true;
        render();
        showWinner(currentPlayer);
        return true;
      }

      if (checkDraw()) {
        gameOver = true;
        render();
        showDraw();
        return true;
      }

      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
      updateStatus();
      render();

      // AI's turn
      if (gameMode === 'ai' && currentPlayer === WHITE && !gameOver) {
        isAiThinking = true;
        updateStatus();
        setTimeout(() => {
          aiMove();
        }, getAiDelay());
      }

      return true;
    }

    function undoMove() {
      if (moveHistory.length === 0 || gameOver) return;

      // In AI mode, undo two moves (player + AI)
      const undoCount = gameMode === 'ai' && moveHistory.length >= 2 ? 2 : 1;
      
      for (let i = 0; i < undoCount && moveHistory.length > 0; i++) {
        const lastMove = moveHistory.pop();
        board[lastMove.y][lastMove.x] = EMPTY;
      }

      currentPlayer = moveHistory.length % 2 === 0 ? BLACK : WHITE;
      updateStatus();
      render();
    }

    function checkWin(x, y, player) {
      const directions = [
        [1, 0],  // horizontal
        [0, 1],  // vertical
        [1, 1],  // diagonal
        [1, -1]  // anti-diagonal
      ];

      for (const [dx, dy] of directions) {
        let count = 1;

        // Positive direction
        for (let i = 1; i < 5; i++) {
          const nx = x + dx * i;
          const ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }

        // Negative direction
        for (let i = 1; i < 5; i++) {
          const nx = x - dx * i;
          const ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }

        if (count >= 5) return true;
      }

      return false;
    }

    function checkDraw() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === EMPTY) return false;
        }
      }
      return true;
    }

    // ========================================
    // æœ€å¼·AIç”¨ - Zobrist Hashing & ç½®æ›è¡¨
    // ========================================
    
    // Zobrist ãƒ†ãƒ¼ãƒ–ãƒ«åˆæœŸåŒ–
    const zobristTable = [];
    for (let y = 0; y < BOARD_SIZE; y++) {
      zobristTable[y] = [];
      for (let x = 0; x < BOARD_SIZE; x++) {
        zobristTable[y][x] = {
          [BLACK]: Math.floor(Math.random() * 2147483647),
          [WHITE]: Math.floor(Math.random() * 2147483647)
        };
      }
    }

    // ç½®æ›è¡¨ï¼ˆãƒˆãƒ©ãƒ³ã‚¹ãƒã‚¸ã‚·ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
    const transpositionTable = new Map();
    const TT_EXACT = 0;
    const TT_LOWER = 1;
    const TT_UPPER = 2;
    const MAX_TT_SIZE = 100000;

    // ç¾åœ¨ã®ç›¤é¢ãƒãƒƒã‚·ãƒ¥
    let currentHash = 0;

    function computeHash() {
      let hash = 0;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            hash ^= zobristTable[y][x][board[y][x]];
          }
        }
      }
      return hash;
    }

    function updateHash(x, y, player) {
      currentHash ^= zobristTable[y][x][player];
    }

    // ç½®æ›è¡¨ã‚¨ãƒ³ãƒˆãƒªã®ä¿å­˜
    function storeTT(hash, depth, score, flag, bestMove) {
      if (transpositionTable.size > MAX_TT_SIZE) {
        // å¤ã„ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤ï¼ˆç°¡æ˜“LRUï¼‰
        const firstKey = transpositionTable.keys().next().value;
        transpositionTable.delete(firstKey);
      }
      transpositionTable.set(hash, { depth, score, flag, bestMove });
    }

    // ç½®æ›è¡¨ã‹ã‚‰ã®æ¤œç´¢
    function probeTT(hash, depth, alpha, beta) {
      const entry = transpositionTable.get(hash);
      if (!entry || entry.depth < depth) return null;
      
      if (entry.flag === TT_EXACT) {
        return { score: entry.score, bestMove: entry.bestMove };
      } else if (entry.flag === TT_LOWER && entry.score >= beta) {
        return { score: entry.score, bestMove: entry.bestMove };
      } else if (entry.flag === TT_UPPER && entry.score <= alpha) {
        return { score: entry.score, bestMove: entry.bestMove };
      }
      return { bestMove: entry.bestMove }; // æœ€å–„æ‰‹ã®ãƒ’ãƒ³ãƒˆã®ã¿
    }

    // ========================================
    // æœ€å¼·AIç”¨ - é«˜åº¦ãªãƒ‘ã‚¿ãƒ¼ãƒ³è©•ä¾¡
    // ========================================
    
    // ãƒ‘ã‚¿ãƒ¼ãƒ³è¾æ›¸ï¼ˆ6ãƒã‚¹ç¯„å›²ã§è©•ä¾¡ï¼‰
    const PATTERN_DICT = {
      // è‡ªåˆ†ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ•°å­—ã¯çŸ³ã®æ•°ã€_ã¯ç©ºãï¼‰
      'XXXXX': 10000000,   // äº”é€£
      '_XXXX_': 500000,    // é–‹æ”¾å››
      'XXXX_': 100000,     // ç‰‡å››
      '_XXXX': 100000,
      'XXX_X': 80000,      // é£›ã³å››
      'XX_XX': 80000,
      'X_XXX': 80000,
      '_XXX_': 50000,      // é–‹æ”¾ä¸‰
      'XXX__': 8000,       // ç‰‡ä¸‰
      '__XXX': 8000,
      '_XX_X_': 40000,     // é£›ã³ä¸‰ï¼ˆé–‹æ”¾ï¼‰
      '_X_XX_': 40000,
      'XX__X': 5000,       // é£›ã³ä¸‰ï¼ˆç‰‡ï¼‰
      'X__XX': 5000,
      '_XX_': 3000,        // é–‹æ”¾äºŒ
      'XX___': 500,        // ç‰‡äºŒ
      '___XX': 500,
      '_X_X_': 2000,       // é£›ã³äºŒ
    };

    // ãƒ©ã‚¤ãƒ³ã‚’ãƒ‘ã‚¿ãƒ¼ãƒ³æ–‡å­—åˆ—ã«å¤‰æ›
    function lineToPattern(line, player) {
      let pattern = '';
      for (const cell of line) {
        if (cell === player) pattern += 'X';
        else if (cell === EMPTY) pattern += '_';
        else pattern += 'O'; // ç›¸æ‰‹
      }
      return pattern;
    }

    // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã«ã‚ˆã‚‹è©•ä¾¡
    function evaluateLinePatterns(startX, startY, dx, dy, player) {
      let score = 0;
      const line = [];
      
      let x = startX, y = startY;
      while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
        line.push(board[y][x]);
        x += dx;
        y += dy;
      }

      // 6ãƒã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§ã‚¹ãƒ©ã‚¤ãƒ‰
      for (let i = 0; i <= line.length - 5; i++) {
        const window5 = line.slice(i, i + 5);
        const pattern5 = lineToPattern(window5, player);
        
        // ç›¸æ‰‹ã®çŸ³ãŒå«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã°ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
        if (!pattern5.includes('O')) {
          for (const [pat, val] of Object.entries(PATTERN_DICT)) {
            if (pattern5.includes(pat) || pat.includes(pattern5)) {
              score += val;
            }
          }
        }
        
        // 6ãƒã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
        if (i + 6 <= line.length) {
          const window6 = line.slice(i, i + 6);
          const pattern6 = lineToPattern(window6, player);
          if (!pattern6.includes('O')) {
            for (const [pat, val] of Object.entries(PATTERN_DICT)) {
              if (pattern6 === pat) {
                score += val;
              }
            }
          }
        }
      }

      return score;
    }

    // æœ€å¼·ç”¨ç›¤é¢è©•ä¾¡
    function evaluateBoardUltimate(player) {
      let score = 0;
      const enemy = -player;

      // å…¨æ–¹å‘ã‚’ã‚¹ã‚­ãƒ£ãƒ³
      // æ¨ª
      for (let y = 0; y < BOARD_SIZE; y++) {
        score += evaluateLinePatterns(0, y, 1, 0, player);
        score -= evaluateLinePatterns(0, y, 1, 0, enemy) * 1.1; // é˜²å¾¡é‡è¦–
      }
      // ç¸¦
      for (let x = 0; x < BOARD_SIZE; x++) {
        score += evaluateLinePatterns(x, 0, 0, 1, player);
        score -= evaluateLinePatterns(x, 0, 0, 1, enemy) * 1.1;
      }
      // æ–œã‚
      for (let x = 0; x < BOARD_SIZE; x++) {
        score += evaluateLinePatterns(x, 0, 1, 1, player);
        score -= evaluateLinePatterns(x, 0, 1, 1, enemy) * 1.1;
        score += evaluateLinePatterns(x, 0, 1, -1, player);
        score -= evaluateLinePatterns(x, 0, 1, -1, enemy) * 1.1;
      }
      for (let y = 1; y < BOARD_SIZE; y++) {
        score += evaluateLinePatterns(0, y, 1, 1, player);
        score -= evaluateLinePatterns(0, y, 1, 1, enemy) * 1.1;
        score += evaluateLinePatterns(0, y, 1, -1, player);
        score -= evaluateLinePatterns(0, y, 1, -1, enemy) * 1.1;
        score += evaluateLinePatterns(BOARD_SIZE - 1, y, -1, 1, player);
        score -= evaluateLinePatterns(BOARD_SIZE - 1, y, -1, 1, enemy) * 1.1;
      }

      // ä¸­å¤®åˆ¶åœ§ãƒœãƒ¼ãƒŠã‚¹
      for (let y = 5; y <= 9; y++) {
        for (let x = 5; x <= 9; x++) {
          if (board[y][x] === player) score += 100;
        }
      }

      return score;
    }

    // ========================================
    // æœ€å¼·AIç”¨ - å€™è£œæ‰‹ç”Ÿæˆï¼ˆé«˜ç²¾åº¦ï¼‰
    // ========================================
    
    function generateCandidatesUltimate(maxCandidates = 20) {
      if (moveHistory.length === 0) {
        return [{ x: 7, y: 7, priority: 1000000 }];
      }

      const candidateMap = new Map();

      // è·é›¢2ä»¥å†…ã®ç©ºããƒã‚¹
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            for (let dy = -2; dy <= 2; dy++) {
              for (let dx = -2; dx <= 2; dx++) {
                const ny = y + dy;
                const nx = x + dx;
                if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE && board[ny][nx] === EMPTY) {
                  const key = `${nx},${ny}`;
                  if (!candidateMap.has(key)) {
                    const priority = quickEvaluateUltimate(nx, ny);
                    candidateMap.set(key, { x: nx, y: ny, priority });
                  }
                }
              }
            }
          }
        }
      }

      const candidates = Array.from(candidateMap.values());
      candidates.sort((a, b) => b.priority - a.priority);
      return candidates.slice(0, maxCandidates);
    }

    // é«˜é€Ÿå„ªå…ˆåº¦è©•ä¾¡ï¼ˆæœ€å¼·ç”¨ï¼‰
    function quickEvaluateUltimate(x, y) {
      let score = 0;
      
      // è‡ªåˆ†ã®è„…å¨
      const myThreats = analyzeThreats(x, y, WHITE);
      if (myThreats.five > 0) return 100000000;
      if (myThreats.openFour > 0) score += 5000000;
      if (myThreats.four > 0) score += 500000;
      if (myThreats.openThree > 0) score += 50000;
      
      // ç›¸æ‰‹ã®è„…å¨
      const enemyThreats = analyzeThreats(x, y, BLACK);
      if (enemyThreats.five > 0) return 90000000;
      if (enemyThreats.openFour > 0) score += 4000000;
      if (enemyThreats.four > 0) score += 400000;
      if (enemyThreats.openThree > 0) score += 40000;
      
      // ã‚³ãƒ³ãƒœæ¤œå‡ºï¼ˆå››ä¸‰ã€åŒå››ã€åŒä¸‰ï¼‰
      if (myThreats.openFour > 0 && myThreats.openThree > 0) score += 2000000;
      if (myThreats.four >= 2) score += 1500000;
      if (myThreats.openThree >= 2) score += 800000;
      
      // ä¸­å¤®ãƒœãƒ¼ãƒŠã‚¹
      const dist = Math.abs(x - 7) + Math.abs(y - 7);
      score += (14 - dist) * 50;
      
      return score;
    }

    // ========================================
    // æœ€å¼·AIç”¨ - Alpha-Beta with ç½®æ›è¡¨
    // ========================================
    
    function alphaBetaUltimate(depth, alpha, beta, isMaximizing, aiPlayer) {
      const hash = computeHash();
      
      // ç½®æ›è¡¨ãƒã‚§ãƒƒã‚¯
      const ttEntry = probeTT(hash, depth, alpha, beta);
      if (ttEntry && ttEntry.score !== undefined) {
        return { score: ttEntry.score, move: ttEntry.bestMove };
      }
      
      // çµ‚ç«¯ãƒã‚§ãƒƒã‚¯
      if (depth === 0) {
        return { score: evaluateBoardUltimate(aiPlayer), move: null };
      }

      const currentPlayer = isMaximizing ? aiPlayer : -aiPlayer;
      
      // å€™è£œæ‰‹ç”Ÿæˆï¼ˆç½®æ›è¡¨ã®æœ€å–„æ‰‹ã‚’å„ªå…ˆï¼‰
      let candidates = generateCandidatesUltimate(depth > 2 ? 12 : 18);
      
      // ç½®æ›è¡¨ã®æœ€å–„æ‰‹ã‚’å…ˆé ­ã«
      if (ttEntry && ttEntry.bestMove) {
        const ttMove = ttEntry.bestMove;
        candidates = candidates.filter(c => c.x !== ttMove.x || c.y !== ttMove.y);
        candidates.unshift(ttMove);
      }

      if (candidates.length === 0) {
        return { score: 0, move: null };
      }

      // å³åº§ã®å‹æ•—ãƒã‚§ãƒƒã‚¯
      for (const { x, y } of candidates) {
        board[y][x] = currentPlayer;
        const win = checkWin(x, y, currentPlayer);
        board[y][x] = EMPTY;
        
        if (win) {
          const winScore = PATTERN_SCORES.FIVE * (depth + 1);
          return { 
            score: isMaximizing ? winScore : -winScore, 
            move: { x, y } 
          };
        }
      }

      let bestMove = candidates[0];
      let ttFlag = TT_UPPER;

      if (isMaximizing) {
        let maxScore = -Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentPlayer;
          updateHash(x, y, currentPlayer);
          
          const result = alphaBetaUltimate(depth - 1, alpha, beta, false, aiPlayer);
          
          board[y][x] = EMPTY;
          updateHash(x, y, currentPlayer);

          if (result.score > maxScore) {
            maxScore = result.score;
            bestMove = { x, y };
          }
          
          alpha = Math.max(alpha, result.score);
          if (beta <= alpha) {
            ttFlag = TT_LOWER;
            break;
          }
        }
        
        if (maxScore > -Infinity) {
          storeTT(hash, depth, maxScore, alpha === maxScore ? TT_EXACT : ttFlag, bestMove);
        }
        return { score: maxScore, move: bestMove };
        
      } else {
        let minScore = Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentPlayer;
          updateHash(x, y, currentPlayer);
          
          const result = alphaBetaUltimate(depth - 1, alpha, beta, true, aiPlayer);
          
          board[y][x] = EMPTY;
          updateHash(x, y, currentPlayer);

          if (result.score < minScore) {
            minScore = result.score;
            bestMove = { x, y };
          }
          
          beta = Math.min(beta, result.score);
          if (beta <= alpha) {
            ttFlag = TT_LOWER;
            break;
          }
        }
        
        if (minScore < Infinity) {
          storeTT(hash, depth, minScore, beta === minScore ? TT_EXACT : ttFlag, bestMove);
        }
        return { score: minScore, move: bestMove };
      }
    }

    // ========================================
    // æœ€å¼·AIç”¨ - åå¾©æ·±åŒ–
    // ========================================
    
    function iterativeDeepening(maxDepth, timeLimit) {
      const startTime = Date.now();
      let bestMove = null;
      let bestScore = -Infinity;
      
      // ç½®æ›è¡¨ã‚¯ãƒªã‚¢ï¼ˆæ–°ã—ã„ã‚²ãƒ¼ãƒ ã®ãŸã‚ï¼‰
      if (moveHistory.length <= 2) {
        transpositionTable.clear();
      }
      
      currentHash = computeHash();
      
      // åå¾©æ·±åŒ–ï¼šæ·±ã•2ã‹ã‚‰é–‹å§‹ã—ã€å¶æ•°ã®ã¿ï¼ˆè©•ä¾¡ãƒã‚¤ã‚¢ã‚¹é˜²æ­¢ï¼‰
      for (let depth = 2; depth <= maxDepth; depth += 2) {
        const result = alphaBetaUltimate(depth, -Infinity, Infinity, true, WHITE);
        
        if (result.move) {
          bestMove = result.move;
          bestScore = result.score;
        }
        
        // æ™‚é–“åˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (Date.now() - startTime > timeLimit) {
          break;
        }
        
        // å‹ã¡ç¢ºå®šãªã‚‰å³çµ‚äº†
        if (bestScore >= PATTERN_SCORES.FIVE) {
          break;
        }
      }
      
      return bestMove;
    }

    // ========================================
    // AI Engine - æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
    // ========================================
    const DIRECTIONS = [
      [1, 0],   // æ¨ª
      [0, 1],   // ç¸¦
      [1, 1],   // æ–œã‚å³ä¸‹
      [1, -1]   // æ–œã‚å³ä¸Š
    ];

    // æ€§æ ¼åˆ¥è¨­å®š
    const AI_CONFIG = {
      aggressive: { depth: 2, attackMult: 1.3, defenseMult: 0.8 },
      defensive:  { depth: 2, attackMult: 0.8, defenseMult: 1.4 },
      strategic:  { depth: 3, attackMult: 1.0, defenseMult: 1.0 },
      ultimate:   { depth: 6, attackMult: 1.0, defenseMult: 1.0 }  // æœ€å¼·
    };

    // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¹ã‚³ã‚¢ï¼ˆå„ªå…ˆé †ä½ã‚’æ˜ç¢ºã«éšå±¤åŒ–ï¼‰
    const PATTERN_SCORES = {
      FIVE:         10000000,  // 5é€£ï¼ˆå‹ã¡ï¼‰
      OPEN_FOUR:    500000,    // é–‹æ”¾å››ï¼ˆæ¬¡ã§å‹ã¡ç¢ºå®šï¼‰
      DOUBLE_THREE: 100000,    // å››ä¸‰ãƒ»ä¸‰ä¸‰ãªã©ã®ã‚³ãƒ³ãƒœ
      FOUR:         50000,     // é–‰ã˜ãŸå››ï¼ˆä¸€æ‰‹ã§æ­¢ã‚ã‚‰ã‚Œã‚‹ï¼‰
      OPEN_THREE:   10000,     // é–‹æ”¾ä¸‰ï¼ˆä¸¡ç«¯ç©ºãï¼‰
      THREE:        1000,      // é–‰ã˜ãŸä¸‰
      OPEN_TWO:     500,       // é–‹æ”¾äºŒ
      TWO:          100,       // é–‰ã˜ãŸäºŒ
      CENTER:       20         // ä¸­å¤®ãƒœãƒ¼ãƒŠã‚¹
    };

    // ========================================
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°è©•ä¾¡
    // ========================================
    
    // 5ãƒã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
    function evaluateWindow(window, player) {
      const enemy = -player;
      let myCount = 0;
      let enemyCount = 0;
      let emptyCount = 0;

      for (const cell of window) {
        if (cell === player) myCount++;
        else if (cell === enemy) enemyCount++;
        else emptyCount++;
      }

      // ä¸¡æ–¹ã®çŸ³ãŒã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯æ¸ˆã¿
      if (myCount > 0 && enemyCount > 0) return 0;

      // è‡ªåˆ†ã®çŸ³ã®ã¿
      if (enemyCount === 0) {
        if (myCount === 5) return PATTERN_SCORES.FIVE;
        if (myCount === 4) return PATTERN_SCORES.OPEN_FOUR;
        if (myCount === 3) return PATTERN_SCORES.OPEN_THREE;
        if (myCount === 2) return PATTERN_SCORES.OPEN_TWO;
        if (myCount === 1) return 10;
      }

      return 0;
    }

    // ãƒ©ã‚¤ãƒ³ä¸Šã®å…¨ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è©•ä¾¡
    function evaluateLine(startX, startY, dx, dy, player) {
      let score = 0;
      const lineLength = [];
      
      // ãƒ©ã‚¤ãƒ³ä¸Šã®ã‚»ãƒ«ã‚’åé›†
      let x = startX, y = startY;
      while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
        lineLength.push(board[y][x]);
        x += dx;
        y += dy;
      }

      // 5ãƒã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ã‚¹ãƒ©ã‚¤ãƒ‰
      for (let i = 0; i <= lineLength.length - 5; i++) {
        const window = lineLength.slice(i, i + 5);
        score += evaluateWindow(window, player);
      }

      return score;
    }

    // ç›¤é¢å…¨ä½“ã‚’è©•ä¾¡
    function evaluateBoard(player) {
      let score = 0;
      const enemy = -player;

      // æ¨ªæ–¹å‘
      for (let y = 0; y < BOARD_SIZE; y++) {
        score += evaluateLine(0, y, 1, 0, player);
        score -= evaluateLine(0, y, 1, 0, enemy);
      }

      // ç¸¦æ–¹å‘
      for (let x = 0; x < BOARD_SIZE; x++) {
        score += evaluateLine(x, 0, 0, 1, player);
        score -= evaluateLine(x, 0, 0, 1, enemy);
      }

      // æ–œã‚å³ä¸‹ï¼ˆå·¦ä¸Šã‹ã‚‰é–‹å§‹ï¼‰
      for (let x = 0; x < BOARD_SIZE; x++) {
        score += evaluateLine(x, 0, 1, 1, player);
        score -= evaluateLine(x, 0, 1, 1, enemy);
      }
      for (let y = 1; y < BOARD_SIZE; y++) {
        score += evaluateLine(0, y, 1, 1, player);
        score -= evaluateLine(0, y, 1, 1, enemy);
      }

      // æ–œã‚å³ä¸Šï¼ˆå·¦ä¸‹ã‹ã‚‰é–‹å§‹ï¼‰
      for (let x = 0; x < BOARD_SIZE; x++) {
        score += evaluateLine(x, BOARD_SIZE - 1, 1, -1, player);
        score -= evaluateLine(x, BOARD_SIZE - 1, 1, -1, enemy);
      }
      for (let y = 0; y < BOARD_SIZE - 1; y++) {
        score += evaluateLine(0, y, 1, -1, player);
        score -= evaluateLine(0, y, 1, -1, enemy);
      }

      // ä¸­å¤®ãƒœãƒ¼ãƒŠã‚¹
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === player) {
            const dist = Math.abs(x - 7) + Math.abs(y - 7);
            score += Math.max(0, 14 - dist) * PATTERN_SCORES.CENTER;
          }
        }
      }

      return score;
    }

    // ========================================
    // é«˜åº¦ãªãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºï¼ˆã‚³ãƒ³ãƒœæ¤œå‡ºç”¨ï¼‰
    // ========================================
    
    // ç‰¹å®šã®æ‰‹ã‚’æ‰“ã£ãŸæ™‚ã®è„…å¨ã‚’åˆ†æ
    function analyzeThreats(x, y, player) {
      const threats = {
        five: 0,
        openFour: 0,
        four: 0,
        openThree: 0,
        three: 0
      };

      board[y][x] = player;

      for (const [dx, dy] of DIRECTIONS) {
        const result = analyzeLinePattern(x, y, dx, dy, player);
        if (result.count >= 5) threats.five++;
        else if (result.count === 4 && result.openEnds === 2) threats.openFour++;
        else if (result.count === 4 && result.openEnds === 1) threats.four++;
        else if (result.count === 3 && result.openEnds === 2) threats.openThree++;
        else if (result.count === 3 && result.openEnds === 1) threats.three++;
      }

      board[y][x] = EMPTY;
      return threats;
    }

    // é£›ã³çŸ³ã‚‚å«ã‚ãŸãƒ©ã‚¤ãƒ³åˆ†æ
    function analyzeLinePattern(x, y, dx, dy, player) {
      let count = 1;
      let openEnds = 0;
      let gaps = 0;

      // æ­£æ–¹å‘
      let consecutive = true;
      let space = 0;
      for (let i = 1; i <= 5; i++) {
        const nx = x + dx * i;
        const ny = y + dy * i;
        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
        
        const cell = board[ny][nx];
        if (cell === player) {
          count++;
          if (!consecutive && space === 1) gaps++; // é£›ã³çŸ³
          consecutive = true;
          space = 0;
        } else if (cell === EMPTY) {
          if (consecutive && count < 5) {
            space++;
            if (space === 1) {
              consecutive = false;
            } else {
              openEnds++;
              break;
            }
          } else {
            openEnds++;
            break;
          }
        } else {
          break;
        }
      }

      // è² æ–¹å‘
      consecutive = true;
      space = 0;
      for (let i = 1; i <= 5; i++) {
        const nx = x - dx * i;
        const ny = y - dy * i;
        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
        
        const cell = board[ny][nx];
        if (cell === player) {
          count++;
          if (!consecutive && space === 1) gaps++;
          consecutive = true;
          space = 0;
        } else if (cell === EMPTY) {
          if (consecutive && count < 5) {
            space++;
            if (space === 1) {
              consecutive = false;
            } else {
              openEnds++;
              break;
            }
          } else {
            openEnds++;
            break;
          }
        } else {
          break;
        }
      }

      // é£›ã³çŸ³ã‚‚æœ‰åŠ¹ãªå½¢ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼ˆãŸã ã—5ãƒã‚¹ä»¥å†…ã«åã¾ã‚‹å ´åˆã®ã¿ï¼‰
      if (gaps > 0 && count >= 3) {
        openEnds = Math.min(openEnds, 1); // é£›ã³çŸ³ã¯ç‰‡å´é–‹æ”¾æ‰±ã„
      }

      return { count: Math.min(count, 5), openEnds, gaps };
    }

    // ========================================
    // å€™è£œæ‰‹ç”Ÿæˆï¼ˆå„ªå…ˆåº¦ä»˜ãï¼‰
    // ========================================
    
    function generateCandidates(maxCandidates = 15) {
      // åˆæ‰‹ã¯ä¸­å¤®
      if (moveHistory.length === 0) {
        return [{ x: 7, y: 7, priority: 1000 }];
      }

      const candidateMap = new Map();

      // æ—¢å­˜ã®çŸ³ã‹ã‚‰è·é›¢2ä»¥å†…
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            for (let dy = -2; dy <= 2; dy++) {
              for (let dx = -2; dx <= 2; dx++) {
                const ny = y + dy;
                const nx = x + dx;
                if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE) {
                  if (board[ny][nx] === EMPTY) {
                    const key = `${nx},${ny}`;
                    if (!candidateMap.has(key)) {
                      // å„ªå…ˆåº¦ã‚’è¨ˆç®—
                      const priority = quickEvaluate(nx, ny);
                      candidateMap.set(key, { x: nx, y: ny, priority });
                    }
                  }
                }
              }
            }
          }
        }
      }

      // å„ªå…ˆåº¦ã§ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šä½ã‚’è¿”ã™
      const candidates = Array.from(candidateMap.values());
      candidates.sort((a, b) => b.priority - a.priority);
      return candidates.slice(0, maxCandidates);
    }

    // é«˜é€Ÿãªå„ªå…ˆåº¦è©•ä¾¡ï¼ˆå€™è£œçµã‚Šè¾¼ã¿ç”¨ï¼‰
    function quickEvaluate(x, y) {
      let score = 0;

      // AIï¼ˆç™½ï¼‰ã®è„…å¨
      const myThreats = analyzeThreats(x, y, WHITE);
      if (myThreats.five > 0) score += 10000000;
      if (myThreats.openFour > 0) score += 500000;
      if (myThreats.four > 0) score += 50000;
      if (myThreats.openThree > 0) score += 10000;

      // äººé–“ï¼ˆé»’ï¼‰ã®è„…å¨ã‚’ãƒ–ãƒ­ãƒƒã‚¯
      const enemyThreats = analyzeThreats(x, y, BLACK);
      if (enemyThreats.five > 0) score += 9000000;
      if (enemyThreats.openFour > 0) score += 400000;
      if (enemyThreats.four > 0) score += 40000;
      if (enemyThreats.openThree > 0) score += 8000;

      // ã‚³ãƒ³ãƒœæ¤œå‡ºï¼ˆå››ä¸‰ãªã©ï¼‰
      if (myThreats.openFour > 0 && myThreats.openThree > 0) score += 200000;
      if (myThreats.four >= 2) score += 150000;
      if (myThreats.openThree >= 2) score += 80000; // ä¸‰ä¸‰

      // ä¸­å¤®ãƒœãƒ¼ãƒŠã‚¹
      const dist = Math.abs(x - 7) + Math.abs(y - 7);
      score += Math.max(0, 14 - dist) * 10;

      return score;
    }

    // ========================================
    // Alpha-Betaæ¢ç´¢
    // ========================================
    
    function alphaBeta(depth, alpha, beta, isMaximizing, aiPlayer) {
      // çµ‚ç«¯æ¡ä»¶
      if (depth === 0) {
        const config = AI_CONFIG[aiType];
        let score = evaluateBoard(aiPlayer);
        // æ€§æ ¼ã«ã‚ˆã‚‹æ”»å®ˆãƒãƒ©ãƒ³ã‚¹èª¿æ•´
        if (isMaximizing) {
          score *= config.attackMult;
        } else {
          score *= config.defenseMult;
        }
        return { score, move: null };
      }

      const currentPlayer = isMaximizing ? aiPlayer : -aiPlayer;
      const candidates = generateCandidates(depth > 1 ? 10 : 15);

      if (candidates.length === 0) {
        return { score: 0, move: null };
      }

      // å³åº§ã®å‹æ•—ãƒã‚§ãƒƒã‚¯
      for (const { x, y } of candidates) {
        board[y][x] = currentPlayer;
        const win = checkWin(x, y, currentPlayer);
        board[y][x] = EMPTY;
        
        if (win) {
          if (isMaximizing) {
            return { score: PATTERN_SCORES.FIVE * (depth + 1), move: { x, y } };
          } else {
            return { score: -PATTERN_SCORES.FIVE * (depth + 1), move: { x, y } };
          }
        }
      }

      let bestMove = candidates[0];

      if (isMaximizing) {
        let maxScore = -Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentPlayer;
          const result = alphaBeta(depth - 1, alpha, beta, false, aiPlayer);
          board[y][x] = EMPTY;

          if (result.score > maxScore) {
            maxScore = result.score;
            bestMove = { x, y };
          }
          alpha = Math.max(alpha, result.score);
          if (beta <= alpha) break; // Î²ã‚«ãƒƒãƒˆ
        }
        
        return { score: maxScore, move: bestMove };
      } else {
        let minScore = Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentPlayer;
          const result = alphaBeta(depth - 1, alpha, beta, true, aiPlayer);
          board[y][x] = EMPTY;

          if (result.score < minScore) {
            minScore = result.score;
            bestMove = { x, y };
          }
          beta = Math.min(beta, result.score);
          if (beta <= alpha) break; // Î±ã‚«ãƒƒãƒˆ
        }
        
        return { score: minScore, move: bestMove };
      }
    }

    // ========================================
    // ç·Šæ€¥æ‰‹ãƒã‚§ãƒƒã‚¯
    // ========================================
    
    function findEmergencyMove() {
      const candidates = generateCandidates(30);

      // 1. è‡ªåˆ†ãŒå‹ã¦ã‚‹æ‰‹
      for (const { x, y } of candidates) {
        board[y][x] = WHITE;
        const win = checkWin(x, y, WHITE);
        board[y][x] = EMPTY;
        if (win) return { x, y, reason: 'win' };
      }

      // 2. ç›¸æ‰‹ã®5é€£ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        board[y][x] = BLACK;
        const lose = checkWin(x, y, BLACK);
        board[y][x] = EMPTY;
        if (lose) return { x, y, reason: 'block5' };
      }

      // 3. è‡ªåˆ†ã®é–‹æ”¾å››ã‚’ä½œã‚‹
      for (const { x, y } of candidates) {
        const threats = analyzeThreats(x, y, WHITE);
        if (threats.openFour > 0) return { x, y, reason: 'openFour' };
      }

      // 4. ç›¸æ‰‹ã®é–‹æ”¾å››ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreats(x, y, BLACK);
        if (threats.openFour > 0) return { x, y, reason: 'blockOpenFour' };
      }

      // 5. å››ä¸‰ãªã©ã®ã‚³ãƒ³ãƒœã‚’ä½œã‚‹
      for (const { x, y } of candidates) {
        const threats = analyzeThreats(x, y, WHITE);
        if (threats.four >= 2 || (threats.four > 0 && threats.openThree > 0)) {
          return { x, y, reason: 'combo' };
        }
      }

      // 6. ç›¸æ‰‹ã®å››ä¸‰ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreats(x, y, BLACK);
        if (threats.four >= 2 || (threats.four > 0 && threats.openThree > 0)) {
          return { x, y, reason: 'blockCombo' };
        }
      }

      return null;
    }

    // ========================================
    // ãƒ¡ã‚¤ãƒ³AIé–¢æ•°
    // ========================================
    
    function aiMove() {
      const config = AI_CONFIG[aiType];

      // åˆæ‰‹ã¯ä¸­å¤®
      if (moveHistory.length === 0) {
        isAiThinking = false;
        makeMove(7, 7);
        return;
      }

      // 2æ‰‹ç›®ã¯ä¸­å¤®ä»˜è¿‘
      if (moveHistory.length === 1) {
        const first = moveHistory[0];
        const offsets = [[1, 1], [-1, -1], [1, -1], [-1, 1], [1, 0], [0, 1]];
        for (const [dx, dy] of offsets) {
          const nx = first.x + dx;
          const ny = first.y + dy;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === EMPTY) {
            isAiThinking = false;
            makeMove(nx, ny);
            return;
          }
        }
      }

      // æœ€å¼·ãƒ¢ãƒ¼ãƒ‰
      if (aiType === 'ultimate') {
        // ç·Šæ€¥æ‰‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰
        const emergency = findEmergencyMove();
        if (emergency) {
          isAiThinking = false;
          makeMove(emergency.x, emergency.y);
          return;
        }

        // åå¾©æ·±åŒ–ã§æœ€å–„æ‰‹ã‚’æ¢ç´¢ï¼ˆæ™‚é–“åˆ¶é™2ç§’ï¼‰
        const bestMove = iterativeDeepening(config.depth, 2000);
        
        isAiThinking = false;
        if (bestMove) {
          makeMove(bestMove.x, bestMove.y);
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          const candidates = generateCandidatesUltimate(10);
          if (candidates.length > 0) {
            makeMove(candidates[0].x, candidates[0].y);
          }
        }
        return;
      }

      // é€šå¸¸AIï¼ˆæ”»æ’ƒå‹ãƒ»é˜²å¾¡å‹ãƒ»ãƒãƒ©ãƒ³ã‚¹å‹ï¼‰
      // ç·Šæ€¥æ‰‹ãƒã‚§ãƒƒã‚¯
      const emergency = findEmergencyMove();
      if (emergency) {
        isAiThinking = false;
        makeMove(emergency.x, emergency.y);
        return;
      }

      // Alpha-Betaæ¢ç´¢
      const result = alphaBeta(config.depth, -Infinity, Infinity, true, WHITE);
      
      isAiThinking = false;
      if (result.move) {
        makeMove(result.move.x, result.move.y);
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        const candidates = generateCandidates(10);
        if (candidates.length > 0) {
          makeMove(candidates[0].x, candidates[0].y);
        }
      }
    }

    function getAiDelay() {
      switch (aiType) {
        case 'aggressive': return 200;  // é€Ÿæ”»ã‚¿ã‚¤ãƒ—
        case 'defensive': return 400;   // æ…é‡ã‚¿ã‚¤ãƒ—
        case 'strategic': return 300;   // ãƒãƒ©ãƒ³ã‚¹ã‚¿ã‚¤ãƒ—
        case 'ultimate': return 100;    // æœ€å¼·ï¼ˆè¨ˆç®—ã«æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§é…å»¶ã¯æœ€å°ï¼‰
        default: return 300;
      }
    }

    // ========================================
    // AI vs AI ãƒãƒˆãƒ«æ©Ÿèƒ½
    // ========================================
    
    function startBattle() {
      if (gameOver) {
        initBoard();
      }
      battleRunning = true;
      battlePaused = false;
      updateBattleButtons();
      runBattle();
    }

    function pauseBattle() {
      battlePaused = !battlePaused;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? 'â–¶ï¸ å†é–‹' : 'â¸ï¸ ä¸€æ™‚åœæ­¢';
      if (!battlePaused && battleRunning) {
        runBattle();
      }
    }

    function stopBattle() {
      battleRunning = false;
      battlePaused = false;
      if (battleTimeoutId) {
        clearTimeout(battleTimeoutId);
        battleTimeoutId = null;
      }
      isAiThinking = false;
      updateBattleButtons();
      updateStatus();
    }

    function updateBattleButtons() {
      document.getElementById('startBattleBtn').disabled = battleRunning && !battlePaused;
      document.getElementById('pauseBattleBtn').disabled = !battleRunning;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? 'â–¶ï¸ å†é–‹' : 'â¸ï¸ ä¸€æ™‚åœæ­¢';
    }

    function runBattle() {
      if (!battleRunning || battlePaused || gameOver) return;

      isAiThinking = true;
      updateStatus();

      const speed = parseInt(document.getElementById('battleSpeed').value);
      
      battleTimeoutId = setTimeout(() => {
        if (!battleRunning || battlePaused || gameOver) {
          isAiThinking = false;
          return;
        }

        // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å¿œã˜ãŸAIã§æ‰‹ã‚’æ±ºå®š
        const currentAiType = currentPlayer === BLACK ? blackAiType : whiteAiType;
        const move = calculateAiMove(currentAiType, currentPlayer);
        
        isAiThinking = false;
        
        if (move) {
          makeMove(move.x, move.y);
          
          // æ¬¡ã®æ‰‹ã¸
          if (!gameOver && battleRunning && !battlePaused) {
            runBattle();
          }
        }
      }, speed);
    }

    // æŒ‡å®šã•ã‚ŒãŸAIã‚¿ã‚¤ãƒ—ã§æ‰‹ã‚’è¨ˆç®—
    function calculateAiMove(type, player) {
      const config = AI_CONFIG[type];

      // åˆæ‰‹ã¯ä¸­å¤®
      if (moveHistory.length === 0) {
        return { x: 7, y: 7 };
      }

      // 2æ‰‹ç›®ã¯ä¸­å¤®ä»˜è¿‘
      if (moveHistory.length === 1) {
        const first = moveHistory[0];
        const offsets = [[1, 1], [-1, -1], [1, -1], [-1, 1], [1, 0], [0, 1]];
        for (const [dx, dy] of offsets) {
          const nx = first.x + dx;
          const ny = first.y + dy;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === EMPTY) {
            return { x: nx, y: ny };
          }
        }
      }

      // ç·Šæ€¥æ‰‹ãƒã‚§ãƒƒã‚¯
      const emergency = findEmergencyMoveForPlayer(player);
      if (emergency) {
        return emergency;
      }

      // æœ€å¼·ãƒ¢ãƒ¼ãƒ‰
      if (type === 'ultimate') {
        currentHash = computeHash();
        return iterativeDeepeningForPlayer(config.depth, 2000, player);
      }

      // é€šå¸¸AI
      const result = alphaBetaForPlayer(config.depth, -Infinity, Infinity, true, player, config);
      return result.move;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡å®šç‰ˆã®ç·Šæ€¥æ‰‹ãƒã‚§ãƒƒã‚¯
    function findEmergencyMoveForPlayer(player) {
      const enemy = -player;
      const candidates = generateCandidates(30);

      // 1. è‡ªåˆ†ãŒå‹ã¦ã‚‹æ‰‹
      for (const { x, y } of candidates) {
        board[y][x] = player;
        const win = checkWin(x, y, player);
        board[y][x] = EMPTY;
        if (win) return { x, y };
      }

      // 2. ç›¸æ‰‹ã®5é€£ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        board[y][x] = enemy;
        const lose = checkWin(x, y, enemy);
        board[y][x] = EMPTY;
        if (lose) return { x, y };
      }

      // 3. è‡ªåˆ†ã®é–‹æ”¾å››ã‚’ä½œã‚‹
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsForPlayer(x, y, player);
        if (threats.openFour > 0) return { x, y };
      }

      // 4. ç›¸æ‰‹ã®é–‹æ”¾å››ã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsForPlayer(x, y, enemy);
        if (threats.openFour > 0) return { x, y };
      }

      // 5. ã‚³ãƒ³ãƒœã‚’ä½œã‚‹
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsForPlayer(x, y, player);
        if (threats.four >= 2 || (threats.four > 0 && threats.openThree > 0)) {
          return { x, y };
        }
      }

      // 6. ç›¸æ‰‹ã®ã‚³ãƒ³ãƒœã‚’é˜»æ­¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsForPlayer(x, y, enemy);
        if (threats.four >= 2 || (threats.four > 0 && threats.openThree > 0)) {
          return { x, y };
        }
      }

      return null;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡å®šç‰ˆã®è„…å¨åˆ†æ
    function analyzeThreatsForPlayer(x, y, player) {
      const threats = {
        five: 0,
        openFour: 0,
        four: 0,
        openThree: 0,
        three: 0
      };

      board[y][x] = player;

      for (const [dx, dy] of DIRECTIONS) {
        const result = analyzeLinePattern(x, y, dx, dy, player);
        if (result.count >= 5) threats.five++;
        else if (result.count === 4 && result.openEnds === 2) threats.openFour++;
        else if (result.count === 4 && result.openEnds === 1) threats.four++;
        else if (result.count === 3 && result.openEnds === 2) threats.openThree++;
        else if (result.count === 3 && result.openEnds === 1) threats.three++;
      }

      board[y][x] = EMPTY;
      return threats;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡å®šç‰ˆã®Alpha-Beta
    function alphaBetaForPlayer(depth, alpha, beta, isMaximizing, aiPlayer, config) {
      if (depth === 0) {
        let score = evaluateBoard(aiPlayer);
        if (isMaximizing) {
          score *= config.attackMult;
        } else {
          score *= config.defenseMult;
        }
        return { score, move: null };
      }

      const currentP = isMaximizing ? aiPlayer : -aiPlayer;
      const candidates = generateCandidates(depth > 1 ? 10 : 15);

      if (candidates.length === 0) {
        return { score: 0, move: null };
      }

      // å³åº§ã®å‹æ•—ãƒã‚§ãƒƒã‚¯
      for (const { x, y } of candidates) {
        board[y][x] = currentP;
        const win = checkWin(x, y, currentP);
        board[y][x] = EMPTY;
        
        if (win) {
          if (isMaximizing) {
            return { score: PATTERN_SCORES.FIVE * (depth + 1), move: { x, y } };
          } else {
            return { score: -PATTERN_SCORES.FIVE * (depth + 1), move: { x, y } };
          }
        }
      }

      let bestMove = candidates[0];

      if (isMaximizing) {
        let maxScore = -Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentP;
          const result = alphaBetaForPlayer(depth - 1, alpha, beta, false, aiPlayer, config);
          board[y][x] = EMPTY;

          if (result.score > maxScore) {
            maxScore = result.score;
            bestMove = { x, y };
          }
          alpha = Math.max(alpha, result.score);
          if (beta <= alpha) break;
        }
        
        return { score: maxScore, move: bestMove };
      } else {
        let minScore = Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentP;
          const result = alphaBetaForPlayer(depth - 1, alpha, beta, true, aiPlayer, config);
          board[y][x] = EMPTY;

          if (result.score < minScore) {
            minScore = result.score;
            bestMove = { x, y };
          }
          beta = Math.min(beta, result.score);
          if (beta <= alpha) break;
        }
        
        return { score: minScore, move: bestMove };
      }
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡å®šç‰ˆã®åå¾©æ·±åŒ–
    function iterativeDeepeningForPlayer(maxDepth, timeLimit, player) {
      const startTime = Date.now();
      let bestMove = null;
      let bestScore = -Infinity;
      
      if (moveHistory.length <= 2) {
        transpositionTable.clear();
      }
      
      currentHash = computeHash();
      
      for (let depth = 2; depth <= maxDepth; depth += 2) {
        const result = alphaBetaUltimateForPlayer(depth, -Infinity, Infinity, true, player);
        
        if (result.move) {
          bestMove = result.move;
          bestScore = result.score;
        }
        
        if (Date.now() - startTime > timeLimit) break;
        if (bestScore >= PATTERN_SCORES.FIVE) break;
      }
      
      return bestMove;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æŒ‡å®šç‰ˆã®æœ€å¼·Alpha-Beta
    function alphaBetaUltimateForPlayer(depth, alpha, beta, isMaximizing, aiPlayer) {
      const hash = computeHash();
      
      const ttEntry = probeTT(hash, depth, alpha, beta);
      if (ttEntry && ttEntry.score !== undefined) {
        return { score: ttEntry.score, move: ttEntry.bestMove };
      }
      
      if (depth === 0) {
        return { score: evaluateBoardUltimate(aiPlayer), move: null };
      }

      const currentP = isMaximizing ? aiPlayer : -aiPlayer;
      
      let candidates = generateCandidatesUltimate(depth > 2 ? 12 : 18);
      
      if (ttEntry && ttEntry.bestMove) {
        const ttMove = ttEntry.bestMove;
        candidates = candidates.filter(c => c.x !== ttMove.x || c.y !== ttMove.y);
        candidates.unshift(ttMove);
      }

      if (candidates.length === 0) {
        return { score: 0, move: null };
      }

      for (const { x, y } of candidates) {
        board[y][x] = currentP;
        const win = checkWin(x, y, currentP);
        board[y][x] = EMPTY;
        
        if (win) {
          const winScore = PATTERN_SCORES.FIVE * (depth + 1);
          return { 
            score: isMaximizing ? winScore : -winScore, 
            move: { x, y } 
          };
        }
      }

      let bestMove = candidates[0];
      let ttFlag = TT_UPPER;

      if (isMaximizing) {
        let maxScore = -Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentP;
          updateHash(x, y, currentP);
          
          const result = alphaBetaUltimateForPlayer(depth - 1, alpha, beta, false, aiPlayer);
          
          board[y][x] = EMPTY;
          updateHash(x, y, currentP);

          if (result.score > maxScore) {
            maxScore = result.score;
            bestMove = { x, y };
          }
          
          alpha = Math.max(alpha, result.score);
          if (beta <= alpha) {
            ttFlag = TT_LOWER;
            break;
          }
        }
        
        if (maxScore > -Infinity) {
          storeTT(hash, depth, maxScore, alpha === maxScore ? TT_EXACT : ttFlag, bestMove);
        }
        return { score: maxScore, move: bestMove };
        
      } else {
        let minScore = Infinity;
        
        for (const { x, y } of candidates) {
          board[y][x] = currentP;
          updateHash(x, y, currentP);
          
          const result = alphaBetaUltimateForPlayer(depth - 1, alpha, beta, true, aiPlayer);
          
          board[y][x] = EMPTY;
          updateHash(x, y, currentP);

          if (result.score < minScore) {
            minScore = result.score;
            bestMove = { x, y };
          }
          
          beta = Math.min(beta, result.score);
          if (beta <= alpha) {
            ttFlag = TT_LOWER;
            break;
          }
        }
        
        if (minScore < Infinity) {
          storeTT(hash, depth, minScore, beta === minScore ? TT_EXACT : ttFlag, bestMove);
        }
        return { score: minScore, move: bestMove };
      }
    }

    // ========================================
    // UI Updates
    // ========================================
    function updateStatus() {
      const status = document.getElementById('status');
      if (gameOver) {
        status.textContent = 'ã‚²ãƒ¼ãƒ çµ‚äº†';
      } else if (isAiThinking) {
        if (gameMode === 'aivai') {
          const aiName = currentPlayer === BLACK ? getAiName(blackAiType) : getAiName(whiteAiType);
          status.textContent = `${currentPlayer === BLACK ? 'âš«' : 'âšª'} ${aiName} æ€è€ƒä¸­...`;
        } else if (aiType === 'ultimate') {
          status.textContent = 'ğŸ‘¹ æœ€å¼·AI æ·±ãæ€è€ƒä¸­...';
        } else {
          status.textContent = 'AIæ€è€ƒä¸­...';
        }
      } else {
        if (gameMode === 'aivai') {
          const aiName = currentPlayer === BLACK ? getAiName(blackAiType) : getAiName(whiteAiType);
          status.textContent = `${currentPlayer === BLACK ? 'âš«' : 'âšª'} ${aiName} ã®ç•ª`;
        } else {
          status.textContent = currentPlayer === BLACK ? 'é»’ã®ç•ªã§ã™' : 'ç™½ã®ç•ªã§ã™';
        }
      }
    }

    function getAiName(type) {
      switch (type) {
        case 'aggressive': return 'ğŸ”¥æ”»æ’ƒå‹';
        case 'defensive': return 'ğŸ›¡ï¸é˜²å¾¡å‹';
        case 'strategic': return 'âš–ï¸ãƒãƒ©ãƒ³ã‚¹å‹';
        case 'ultimate': return 'ğŸ‘¹æœ€å¼·';
        default: return type;
      }
    }

    function showWinner(player) {
      const overlay = document.getElementById('winnerOverlay');
      const stone = document.getElementById('winnerStone');
      const text = document.getElementById('winnerText');

      stone.className = 'stone-icon ' + (player === BLACK ? 'black' : 'white');
      
      if (gameMode === 'aivai') {
        const winnerAi = player === BLACK ? getAiName(blackAiType) : getAiName(whiteAiType);
        const loserAi = player === BLACK ? getAiName(whiteAiType) : getAiName(blackAiType);
        text.textContent = `${winnerAi} ã®å‹ã¡ï¼`;
      } else if (gameMode === 'ai') {
        text.textContent = player === BLACK ? 'ã‚ãªãŸã®å‹ã¡ï¼' : 'AIã®å‹ã¡ï¼';
      } else {
        text.textContent = player === BLACK ? 'é»’ã®å‹ã¡ï¼' : 'ç™½ã®å‹ã¡ï¼';
      }

      if (player === BLACK) {
        scores.black++;
      } else {
        scores.white++;
      }
      updateScores();

      // AIåŒå£«ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ãƒãƒˆãƒ«ã‚’åœæ­¢
      if (gameMode === 'aivai') {
        stopBattle();
      }

      overlay.classList.add('visible');
    }

    function showDraw() {
      const overlay = document.getElementById('winnerOverlay');
      const stone = document.getElementById('winnerStone');
      const text = document.getElementById('winnerText');

      stone.className = 'stone-icon';
      stone.style.background = 'linear-gradient(90deg, #1a1a1a 50%, #fff 50%)';
      text.textContent = 'å¼•ãåˆ†ã‘ï¼';

      overlay.classList.add('visible');
    }

    function updateScores() {
      document.getElementById('blackScore').textContent = scores.black;
      document.getElementById('whiteScore').textContent = scores.white;
    }

    // ========================================
    // Event Handlers
    // ========================================
    function getGridPosition(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      
      const gridX = Math.round((x - padding) / cellSize);
      const gridY = Math.round((y - padding) / cellSize);
      
      return { x: gridX, y: gridY };
    }

    canvas.addEventListener('click', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer === WHITE) return;

      const pos = getGridPosition(e.clientX, e.clientY);
      makeMove(pos.x, pos.y);
    });

    canvas.addEventListener('touchend', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer === WHITE) return;

      e.preventDefault();
      const touch = e.changedTouches[0];
      const pos = getGridPosition(touch.clientX, touch.clientY);
      makeMove(pos.x, pos.y);
    });

    // Mode buttons
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        
        document.getElementById('aiTypes').classList.toggle('visible', gameMode === 'ai');
        document.getElementById('aiVsAiSelector').classList.toggle('visible', gameMode === 'aivai');
        document.getElementById('battleControls').classList.toggle('visible', gameMode === 'aivai');
        
        stopBattle();
        initBoard();
      });
    });

    // AI type buttons
    document.querySelectorAll('.ai-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ai-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiType = btn.dataset.ai;
        initBoard();
      });
    });

    // Control buttons
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('resetBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      document.getElementById('winnerOverlay').classList.remove('visible');
      initBoard();
    });

    // AI vs AI selector buttons
    document.querySelectorAll('#blackAiButtons .ai-select-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#blackAiButtons .ai-select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        blackAiType = btn.dataset.ai;
      });
    });

    document.querySelectorAll('#whiteAiButtons .ai-select-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#whiteAiButtons .ai-select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        whiteAiType = btn.dataset.ai;
      });
    });

    // Battle control buttons
    document.getElementById('startBattleBtn').addEventListener('click', startBattle);
    document.getElementById('pauseBattleBtn').addEventListener('click', pauseBattle);
    document.getElementById('stopBattleBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });

    // Window resize
    window.addEventListener('resize', () => {
      initCanvas();
      render();
    });

    // ========================================
    // Initialize
    // ========================================
    initCanvas();
    initBoard();
  </script>
</body>
</html>
