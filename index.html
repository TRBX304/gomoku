<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>‰∫îÁõÆ‰∏¶„Åπ - ‰∏¶ÂàóAIÁâà</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      color: #fff;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 12px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .mode-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #2d3748;
      color: #fff;
    }

    .mode-btn:hover {
      transform: translateY(-2px);
    }

    .mode-btn.active {
      background: #4299e1;
      box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
    }

    .ai-selector {
      display: none;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
      padding: 16px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .ai-selector.visible {
      display: flex;
    }

    .ai-row {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .ai-row-label {
      font-size: 0.85rem;
      width: 60px;
      text-align: right;
    }

    .level-btn {
      padding: 8px 12px;
      border: 2px solid #4a5568;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .level-btn:hover {
      transform: scale(1.05);
    }

    .level-btn.active {
      border-color: #4299e1;
      background: #4299e1;
    }

    .turn-btn {
      padding: 8px 16px;
      border: 2px solid #4a5568;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .turn-btn:hover {
      transform: scale(1.05);
    }

    .turn-btn.active {
      border-color: #f59e0b;
      background: #f59e0b;
    }

    .level-btn.ultimate {
      border-color: #a855f7;
      background: rgba(168, 85, 247, 0.2);
    }

    .level-btn.ultimate.active {
      background: linear-gradient(135deg, #a855f7 0%, #6366f1 100%);
      animation: ultimatePulse 2s infinite;
    }

    .personality-btn {
      padding: 6px 12px;
      border: 2px solid transparent;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      color: #fff;
    }

    .personality-btn.aggressive {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
    }
    .personality-btn.aggressive.active {
      background: #ef4444;
    }

    .personality-btn.defensive {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
    }
    .personality-btn.defensive.active {
      background: #3b82f6;
    }

    .personality-btn.balanced {
      background: rgba(34, 197, 94, 0.2);
      border-color: #22c55e;
    }
    .personality-btn.balanced.active {
      background: #22c55e;
    }

    @keyframes ultimatePulse {
      0%, 100% { box-shadow: 0 0 5px #a855f7; }
      50% { box-shadow: 0 0 20px #a855f7, 0 0 30px #6366f1; }
    }

    .ai-vs-ai-selector {
      display: none;
      flex-direction: column;
      gap: 16px;
      margin-bottom: 16px;
      padding: 16px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
    }

    .ai-vs-ai-selector.visible {
      display: flex;
    }

    .ai-vs-ai-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: center;
    }

    .ai-config-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .ai-config-group label {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .ai-config-buttons {
      display: flex;
      gap: 4px;
    }

    .ai-config-btn {
      padding: 6px 10px;
      border: 2px solid #4a5568;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .ai-config-btn:hover {
      transform: scale(1.05);
    }

    .ai-config-btn.active {
      border-color: #4299e1;
      background: #4299e1;
    }

    .ai-config-btn.ultimate.active {
      border-color: #a855f7;
      background: #a855f7;
    }

    .personality-mini {
      padding: 4px 8px;
      border: 2px solid transparent;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
      color: #fff;
    }

    .personality-mini.aggressive { background: rgba(239, 68, 68, 0.3); border-color: #ef4444; }
    .personality-mini.aggressive.active { background: #ef4444; }
    .personality-mini.defensive { background: rgba(59, 130, 246, 0.3); border-color: #3b82f6; }
    .personality-mini.defensive.active { background: #3b82f6; }
    .personality-mini.balanced { background: rgba(34, 197, 94, 0.3); border-color: #22c55e; }
    .personality-mini.balanced.active { background: #22c55e; }

    .vs-label {
      font-size: 1.5rem;
      font-weight: bold;
      color: #f59e0b;
    }

    .battle-controls {
      display: none;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .battle-controls.visible {
      display: flex;
    }

    .battle-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .battle-btn.start { background: #22c55e; color: #fff; }
    .battle-btn.pause { background: #f59e0b; color: #fff; }
    .battle-btn.stop { background: #ef4444; color: #fff; }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.85rem;
    }

    .speed-control input { width: 80px; }

    .status {
      font-size: 1.1rem;
      margin-bottom: 12px;
      padding: 8px 20px;
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      transition: all 0.3s;
    }

    .status.winner {
      background: #22c55e;
      font-weight: bold;
      animation: winPulse 1s ease-in-out infinite;
    }

    @keyframes winPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .worker-status {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.75rem;
    }

    .worker-indicator {
      padding: 4px 8px;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      transition: all 0.2s;
    }

    .worker-indicator.active {
      background: #22c55e;
      animation: pulse 0.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .board-container {
      position: relative;
      touch-action: none;
    }

    canvas {
      display: block;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .ctrl-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: #4a5568;
      color: #fff;
    }

    .ctrl-btn:hover {
      background: #5a6578;
      transform: translateY(-2px);
    }

    .ctrl-btn.primary {
      background: #48bb78;
    }

    .ctrl-btn.primary:hover {
      background: #38a169;
    }

    .score-board {
      display: flex;
      gap: 24px;
      margin-bottom: 12px;
      font-size: 1rem;
    }

    .score {
      padding: 6px 16px;
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
    }

    .score.black { border-left: 4px solid #1a1a1a; }
    .score.white { border-left: 4px solid #fff; }

    .winner-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .winner-overlay.visible { display: flex; }

    .winner-modal {
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      padding: 32px 48px;
      border-radius: 16px;
      text-align: center;
      animation: popIn 0.3s ease-out;
    }

    @keyframes popIn {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .winner-modal h2 {
      font-size: 2rem;
      margin-bottom: 16px;
    }

    .winner-modal .stone-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      margin: 0 auto 16px;
    }

    .winner-modal .stone-icon.black {
      background: radial-gradient(circle at 30% 30%, #4a4a4a, #1a1a1a);
    }

    .winner-modal .stone-icon.white {
      background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    }

    .winner-modal button {
      margin-top: 16px;
      padding: 12px 32px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      background: #4299e1;
      color: #fff;
    }
  </style>
</head>
<body>
  <h1>üéØ ‰∫îÁõÆ‰∏¶„Åπ</h1>

  <div class="mode-selector">
    <button class="mode-btn active" data-mode="pvp">üë• ‰∫å‰∫∫„Éó„É¨„Ç§</button>
    <button class="mode-btn" data-mode="ai">ü§ñ AIÂØæÊà¶</button>
    <button class="mode-btn" data-mode="aivai">ü§ñ‚öîÔ∏èü§ñ AIÂêåÂ£´</button>
  </div>

  <!-- AIÂØæÊà¶Áî®„Çª„É¨„ÇØ„Çø„Éº -->
  <div class="ai-selector" id="aiSelector">
    <div class="ai-row">
      <span class="ai-row-label">„ÅÇ„Å™„Åü:</span>
      <button class="turn-btn active" data-turn="black">‚ö´ ÂÖàÊâã</button>
      <button class="turn-btn" data-turn="white">‚ö™ ÂæåÊâã</button>
    </div>
    <div class="ai-row">
      <span class="ai-row-label">„É¨„Éô„É´:</span>
      <button class="level-btn active" data-level="1">Lv.1</button>
      <button class="level-btn" data-level="2">Lv.2</button>
      <button class="level-btn" data-level="3">Lv.3</button>
      <button class="level-btn ultimate" data-level="4">üëπÊúÄÂº∑</button>
    </div>
    <div class="ai-row" id="personalityRow">
      <span class="ai-row-label">ÊÄßÊ†º:</span>
      <button class="personality-btn aggressive active" data-personality="aggressive">üî• ÊîªÊíÉ</button>
      <button class="personality-btn defensive" data-personality="defensive">üõ°Ô∏è Èò≤Âæ°</button>
      <button class="personality-btn balanced" data-personality="balanced">‚öñÔ∏è „Éê„É©„É≥„Çπ</button>
    </div>
  </div>

  <!-- AIÂêåÂ£´ÂØæÊà¶Áî®„Çª„É¨„ÇØ„Çø„Éº -->
  <div class="ai-vs-ai-selector" id="aiVsAiSelector">
    <div class="ai-vs-ai-row">
      <div class="ai-config-group">
        <label>‚ö´ ÈªíAI</label>
        <div class="ai-config-buttons" id="blackLevelBtns">
          <button class="ai-config-btn active" data-level="1">Lv1</button>
          <button class="ai-config-btn" data-level="2">Lv2</button>
          <button class="ai-config-btn" data-level="3">Lv3</button>
          <button class="ai-config-btn ultimate" data-level="4">üëπ</button>
        </div>
        <div class="ai-config-buttons" id="blackPersonalityBtns">
          <button class="personality-mini aggressive active" data-personality="aggressive">üî•</button>
          <button class="personality-mini defensive" data-personality="defensive">üõ°Ô∏è</button>
          <button class="personality-mini balanced" data-personality="balanced">‚öñÔ∏è</button>
        </div>
      </div>
      
      <div class="vs-label">VS</div>
      
      <div class="ai-config-group">
        <label>‚ö™ ÁôΩAI</label>
        <div class="ai-config-buttons" id="whiteLevelBtns">
          <button class="ai-config-btn" data-level="1">Lv1</button>
          <button class="ai-config-btn" data-level="2">Lv2</button>
          <button class="ai-config-btn" data-level="3">Lv3</button>
          <button class="ai-config-btn ultimate active" data-level="4">üëπ</button>
        </div>
        <div class="ai-config-buttons" id="whitePersonalityBtns">
          <button class="personality-mini aggressive" data-personality="aggressive">üî•</button>
          <button class="personality-mini defensive" data-personality="defensive">üõ°Ô∏è</button>
          <button class="personality-mini balanced active" data-personality="balanced">‚öñÔ∏è</button>
        </div>
      </div>
    </div>
  </div>

  <div class="score-board">
    <div class="score black">‚ö´ Èªí: <span id="blackScore">0</span></div>
    <div class="score white">‚ö™ ÁôΩ: <span id="whiteScore">0</span></div>
  </div>

  <div class="status" id="status">Èªí„ÅÆÁï™„Åß„Åô</div>

  <div class="worker-status" id="workerStatus">
    <div class="worker-indicator" id="worker0">W1</div>
    <div class="worker-indicator" id="worker1">W2</div>
    <div class="worker-indicator" id="worker2">W3</div>
    <div class="worker-indicator" id="worker3">W4</div>
  </div>

  <div class="battle-controls" id="battleControls">
    <button class="battle-btn start" id="startBattleBtn">‚ñ∂Ô∏è ÈñãÂßã</button>
    <button class="battle-btn pause" id="pauseBattleBtn">‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢</button>
    <button class="battle-btn stop" id="stopBattleBtn">‚èπÔ∏è ÂÅúÊ≠¢</button>
    <div class="speed-control">
      <label>ÈÄüÂ∫¶:</label>
      <input type="range" id="battleSpeed" min="100" max="2000" value="500">
    </div>
  </div>

  <div class="board-container">
    <canvas id="board"></canvas>
  </div>

  <div class="controls">
    <button class="ctrl-btn" id="undoBtn">‚Ü©Ô∏è ÂæÖ„Å£„Åü</button>
    <button class="ctrl-btn primary" id="resetBtn">üîÑ „É™„Çª„ÉÉ„Éà</button>
  </div>

  <div class="winner-overlay" id="winnerOverlay">
    <div class="winner-modal">
      <div class="stone-icon" id="winnerStone"></div>
      <h2 id="winnerText">Èªí„ÅÆÂãù„Å°ÔºÅ</h2>
      <button id="playAgainBtn">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
    </div>
  </div>

  <script>
    // ========================================
    // Worker Code
    // ========================================
    const workerCode = `
      const BOARD_SIZE = 15;
      const EMPTY = 0;
      const BLACK = 1;
      const WHITE = -1;

      const DIRECTIONS = [[1, 0], [0, 1], [1, 1], [1, -1]];

      const PATTERN_SCORES = {
        FIVE: 10000000,
        OPEN_FOUR: 500000,
        FOUR: 50000,
        OPEN_THREE: 10000,
        THREE: 1000,
        OPEN_TWO: 500,
        TWO: 100
      };

      const PATTERN_DICT = {
        // ===== ‰∫îÈÄ£ÔºàÂãù„Å°Ôºâ =====
        'XXXXX': 10000000,
        
        // ===== ÈñãÊîæÂõõÔºàÊ¨°„ÅßÂãù„Å°Á¢∫ÂÆöÔºâ =====
        '_XXXX_': 5000000,
        
        // ===== ÂõõÔºàÁâáÂÅ¥Èñâ„ÅòÔºâ =====
        'XXXX_': 500000,
        '_XXXX': 500000,
        'OXXXX_': 500000,
        '_XXXXO': 500000,
        
        // ===== È£õ„Å≥ÂõõÔºàÈùûÂ∏∏„Å´Âç±Èô∫Ôºâ =====
        'XXX_X': 450000,
        'X_XXX': 450000,
        'XX_XX': 450000,
        '_XXX_X_': 400000,
        '_X_XXX_': 400000,
        '_XX_XX_': 400000,
        
        // ===== ÈñãÊîæ‰∏âÔºà‰∏°ÂÅ¥Á©∫„ÅçÔºâ =====
        '_XXX_': 50000,
        '__XXX__': 50000,
        '_XXX__': 45000,
        '__XXX_': 45000,
        
        // ===== È£õ„Å≥‰∏âÔºàÈñãÊîæ„ÉªÂç±Èô∫Ôºâ =====
        '_XX_X_': 40000,
        '_X_XX_': 40000,
        '_X_X_X_': 35000,
        '__XX_X_': 30000,
        '_X_XX__': 30000,
        
        // ===== Áâá‰∏â =====
        'XXX__': 8000,
        '__XXX': 8000,
        'OXXX__': 8000,
        '__XXXO': 8000,
        'OXXX_': 7000,
        '_XXXO': 7000,
        
        // ===== È£õ„Å≥‰∏âÔºàÁâáÂÅ¥Èñâ„ÅòÔºâ =====
        'XX__X': 6000,
        'X__XX': 6000,
        'XX_X_': 6000,
        '_X_XX': 6000,
        'X_X_X': 5500,
        'OXX_X_': 5000,
        '_X_XXO': 5000,
        'OX_XX_': 5000,
        '_XX_XO': 5000,
        
        // ===== ÈñãÊîæ‰∫å =====
        '_XX_': 3000,
        '__XX__': 3500,
        '_XX__': 2500,
        '__XX_': 2500,
        '___XX___': 3000,
        
        // ===== È£õ„Å≥‰∫å =====
        '_X_X_': 2500,
        '__X_X__': 2800,
        'X__X': 1500,
        '_X__X_': 2000,
        'X___X': 1000,
        
        // ===== Áâá‰∫å =====
        'XX___': 500,
        '___XX': 500,
        'OXX___': 500,
        '___XXO': 500,
        'OXX__': 400,
        '__XXO': 400,
        
        // ===== ÂçòÁü≥ÔºàÁô∫Â±ïÊÄßÔºâ =====
        '__X__': 100,
        '_X_': 50,
      };

      // ÊÄßÊ†º„Å´„Çà„ÇãÊîªÊíÉ„ÉªÈò≤Âæ°‰øÇÊï∞
      const PERSONALITY = {
        aggressive: { attack: 1.3, defense: 0.8 },
        defensive:  { attack: 0.8, defense: 1.4 },
        balanced:   { attack: 1.0, defense: 1.0 }
      };

      let board = [];

      function checkWin(x, y, player) {
        for (const [dx, dy] of DIRECTIONS) {
          let count = 1;
          for (let i = 1; i < 5; i++) {
            const nx = x + dx * i, ny = y + dy * i;
            if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
            if (board[ny][nx] !== player) break;
            count++;
          }
          for (let i = 1; i < 5; i++) {
            const nx = x - dx * i, ny = y - dy * i;
            if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
            if (board[ny][nx] !== player) break;
            count++;
          }
          if (count >= 5) return true;
        }
        return false;
      }

      function lineToPattern(line, player) {
        let pattern = '';
        for (const cell of line) {
          if (cell === player) pattern += 'X';
          else if (cell === EMPTY) pattern += '_';
          else pattern += 'O';
        }
        return pattern;
      }

      function evaluateLinePatterns(startX, startY, dx, dy, player) {
        let score = 0;
        const line = [];
        let x = startX, y = startY;
        while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
          line.push(board[y][x]);
          x += dx;
          y += dy;
        }
        for (let i = 0; i <= line.length - 5; i++) {
          const window5 = line.slice(i, i + 5);
          const pattern5 = lineToPattern(window5, player);
          if (!pattern5.includes('O')) {
            for (const [pat, val] of Object.entries(PATTERN_DICT)) {
              if (pattern5.includes(pat) || pat.includes(pattern5)) {
                score += val;
              }
            }
          }
        }
        return score;
      }

      function evaluateBoard(player, personality) {
        let score = 0;
        const enemy = -player;
        const p = PERSONALITY[personality];
        
        // ===== „É©„Ç§„É≥Ë©ï‰æ° =====
        // Ê®™
        for (let y = 0; y < BOARD_SIZE; y++) {
          score += evaluateLinePatterns(0, y, 1, 0, player) * p.attack;
          score -= evaluateLinePatterns(0, y, 1, 0, enemy) * p.defense * 1.1;
        }
        // Á∏¶
        for (let x = 0; x < BOARD_SIZE; x++) {
          score += evaluateLinePatterns(x, 0, 0, 1, player) * p.attack;
          score -= evaluateLinePatterns(x, 0, 0, 1, enemy) * p.defense * 1.1;
        }
        // Êñú„ÇÅÔºàÂè≥‰∏ã„Åå„ÇäÔºâ
        for (let x = 0; x < BOARD_SIZE; x++) {
          score += evaluateLinePatterns(x, 0, 1, 1, player) * p.attack;
          score -= evaluateLinePatterns(x, 0, 1, 1, enemy) * p.defense * 1.1;
        }
        for (let y = 1; y < BOARD_SIZE; y++) {
          score += evaluateLinePatterns(0, y, 1, 1, player) * p.attack;
          score -= evaluateLinePatterns(0, y, 1, 1, enemy) * p.defense * 1.1;
        }
        // Êñú„ÇÅÔºàÂè≥‰∏ä„Åå„ÇäÔºâ
        for (let x = 0; x < BOARD_SIZE; x++) {
          score += evaluateLinePatterns(x, BOARD_SIZE - 1, 1, -1, player) * p.attack;
          score -= evaluateLinePatterns(x, BOARD_SIZE - 1, 1, -1, enemy) * p.defense * 1.1;
        }
        for (let y = 0; y < BOARD_SIZE - 1; y++) {
          score += evaluateLinePatterns(0, y, 1, -1, player) * p.attack;
          score -= evaluateLinePatterns(0, y, 1, -1, enemy) * p.defense * 1.1;
        }
        
        // ===== ‰∏≠Â§ÆÂà∂Âúß„Éú„Éº„Éä„ÇπÔºàÂº∑ÂåñÔºâ =====
        for (let y = 4; y <= 10; y++) {
          for (let x = 4; x <= 10; x++) {
            if (board[y][x] === player) {
              const centerDist = Math.abs(x - 7) + Math.abs(y - 7);
              score += (7 - centerDist) * 80 + 150;
            } else if (board[y][x] === enemy) {
              const centerDist = Math.abs(x - 7) + Math.abs(y - 7);
              score -= (7 - centerDist) * 60 + 100;
            }
          }
        }
        
        // ===== Áü≥„ÅÆÈÄ£Áµê„Éú„Éº„Éä„Çπ =====
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x] === player) {
              let connections = 0;
              for (const [dx, dy] of DIRECTIONS) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                  if (board[ny][nx] === player) connections++;
                }
                const nx2 = x - dx, ny2 = y - dy;
                if (nx2 >= 0 && nx2 < BOARD_SIZE && ny2 >= 0 && ny2 < BOARD_SIZE) {
                  if (board[ny2][nx2] === player) connections++;
                }
              }
              score += connections * 40;
            }
          }
        }
        
        // ===== Áô∫Â±ïÊÄß„Éú„Éº„Éä„ÇπÔºàÁ©∫„Åç„Éû„Çπ„Å∏„ÅÆÊé•Á∂öÔºâ =====
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x] === player) {
              let openSpaces = 0;
              for (const [dx, dy] of DIRECTIONS) {
                for (const dir of [1, -1]) {
                  const nx = x + dx * dir, ny = y + dy * dir;
                  if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                    if (board[ny][nx] === EMPTY) openSpaces++;
                  }
                }
              }
              score += openSpaces * 15;
            }
          }
        }
        
        return score;
      }

      function analyzeLinePattern(x, y, dx, dy, player) {
        let count = 1;
        let openEnds = 0;
        for (let i = 1; i <= 5; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          const cell = board[ny][nx];
          if (cell === player) count++;
          else if (cell === EMPTY) { openEnds++; break; }
          else break;
        }
        for (let i = 1; i <= 5; i++) {
          const nx = x - dx * i, ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          const cell = board[ny][nx];
          if (cell === player) count++;
          else if (cell === EMPTY) { openEnds++; break; }
          else break;
        }
        return { count: Math.min(count, 5), openEnds };
      }

      function analyzeThreats(x, y, player) {
        const threats = { five: 0, openFour: 0, four: 0, openThree: 0, three: 0 };
        board[y][x] = player;
        for (const [dx, dy] of DIRECTIONS) {
          const result = analyzeLinePattern(x, y, dx, dy, player);
          if (result.count >= 5) threats.five++;
          else if (result.count === 4 && result.openEnds === 2) threats.openFour++;
          else if (result.count === 4 && result.openEnds === 1) threats.four++;
          else if (result.count === 3 && result.openEnds === 2) threats.openThree++;
          else if (result.count === 3 && result.openEnds === 1) threats.three++;
        }
        board[y][x] = EMPTY;
        return threats;
      }

      function quickEvaluate(x, y, player) {
        let score = 0;
        const enemy = -player;
        const myThreats = analyzeThreats(x, y, player);
        const enemyThreats = analyzeThreats(x, y, enemy);
        
        // ===== Âç≥Âãù„Å° =====
        if (myThreats.five > 0) return 100000000;
        
        // ===== Áõ∏Êâã„ÅÆÂç≥Âãù„Å°„ÇíÈò≤„Åê =====
        if (enemyThreats.five > 0) return 95000000;
        
        // ===== ÈñãÊîæÂõõÔºà„Åª„ÅºÂãù„Å°Á¢∫ÂÆöÔºâ =====
        if (myThreats.openFour > 0) return 90000000;
        
        // ===== Áõ∏Êâã„ÅÆÈñãÊîæÂõõ„ÇíÈò≤„Åê =====
        if (enemyThreats.openFour > 0) return 85000000;
        
        // ===== Âõõ‰∏â„Ç≥„É≥„ÉúÔºàÂãù„Å°Á¢∫ÂÆöÔºâ =====
        if (myThreats.four > 0 && myThreats.openThree > 0) return 80000000;
        
        // ===== ÂèåÂõõÔºàÂãù„Å°Á¢∫ÂÆöÔºâ =====
        if (myThreats.four >= 2) return 75000000;
        
        // ===== Áõ∏Êâã„ÅÆÂõõ‰∏â„ÇíÈò≤„Åê =====
        if (enemyThreats.four > 0 && enemyThreats.openThree > 0) return 70000000;
        
        // ===== Áõ∏Êâã„ÅÆÂèåÂõõ„ÇíÈò≤„Åê =====
        if (enemyThreats.four >= 2) return 65000000;
        
        // ===== Âèå‰∏âÔºàÂº∑Âäõ„Å™Êîª„ÇÅÔºâ =====
        if (myThreats.openThree >= 2) return 60000000;
        
        // ===== Áõ∏Êâã„ÅÆÂèå‰∏â„ÇíÈò≤„Åê =====
        if (enemyThreats.openThree >= 2) return 55000000;
        
        // ===== ÂõõÔºã‰∏âÔºàÊ∫ñ„Ç≥„É≥„ÉúÔºâ =====
        if (myThreats.four > 0 && myThreats.three > 0) score += 3000000;
        if (enemyThreats.four > 0 && enemyThreats.three > 0) score += 2500000;
        
        // ===== ÈÄöÂ∏∏„ÅÆËÑÖÂ®ÅË©ï‰æ° =====
        if (myThreats.four > 0) score += 500000;
        if (myThreats.openThree > 0) score += 50000;
        if (myThreats.three > 0) score += 5000;
        
        if (enemyThreats.four > 0) score += 450000;
        if (enemyThreats.openThree > 0) score += 45000;
        if (enemyThreats.three > 0) score += 4500;
        
        // ===== ‰∏≠Â§ÆÂà∂Âúß„Éú„Éº„Éä„Çπ =====
        const dist = Math.abs(x - 7) + Math.abs(y - 7);
        score += (14 - dist) * 100;
        
        // ===== Èö£Êé•„Éú„Éº„Éä„ÇπÔºàÁü≥„ÅÆÈÄ£ÁµêÊÄßÔºâ =====
        for (const [dx, dy] of DIRECTIONS) {
          for (const dir of [1, -1]) {
            const nx = x + dx * dir, ny = y + dy * dir;
            if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
              if (board[ny][nx] === player) score += 200;
              else if (board[ny][nx] === enemy) score += 150;
            }
          }
        }
        
        return score;
      }

      function alphaBeta(depth, alpha, beta, isMaximizing, aiPlayer, personality, candidates) {
        if (depth === 0) {
          return { score: evaluateBoard(aiPlayer, personality), move: null };
        }

        const currentPlayer = isMaximizing ? aiPlayer : -aiPlayer;

        for (const { x, y } of candidates) {
          board[y][x] = currentPlayer;
          const win = checkWin(x, y, currentPlayer);
          board[y][x] = EMPTY;
          if (win) {
            const winScore = PATTERN_SCORES.FIVE * (depth + 1);
            return { score: isMaximizing ? winScore : -winScore, move: { x, y } };
          }
        }

        let bestMove = candidates[0];

        if (isMaximizing) {
          let maxScore = -Infinity;
          for (const { x, y } of candidates) {
            board[y][x] = currentPlayer;
            const childCandidates = generateChildCandidates(x, y, candidates, aiPlayer);
            const result = alphaBeta(depth - 1, alpha, beta, false, aiPlayer, personality, childCandidates);
            board[y][x] = EMPTY;
            if (result.score > maxScore) {
              maxScore = result.score;
              bestMove = { x, y };
            }
            alpha = Math.max(alpha, result.score);
            if (beta <= alpha) break;
          }
          return { score: maxScore, move: bestMove };
        } else {
          let minScore = Infinity;
          for (const { x, y } of candidates) {
            board[y][x] = currentPlayer;
            const childCandidates = generateChildCandidates(x, y, candidates, aiPlayer);
            const result = alphaBeta(depth - 1, alpha, beta, true, aiPlayer, personality, childCandidates);
            board[y][x] = EMPTY;
            if (result.score < minScore) {
              minScore = result.score;
              bestMove = { x, y };
            }
            beta = Math.min(beta, result.score);
            if (beta <= alpha) break;
          }
          return { score: minScore, move: bestMove };
        }
      }

      function generateChildCandidates(lastX, lastY, parentCandidates, aiPlayer) {
        const candidateSet = new Set();
        const newCandidates = [];

        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const ny = lastY + dy, nx = lastX + dx;
            if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE && board[ny][nx] === EMPTY) {
              const key = nx + ',' + ny;
              if (!candidateSet.has(key)) {
                candidateSet.add(key);
                newCandidates.push({ x: nx, y: ny, priority: quickEvaluate(nx, ny, aiPlayer) });
              }
            }
          }
        }

        for (const c of parentCandidates) {
          if (board[c.y][c.x] === EMPTY) {
            const key = c.x + ',' + c.y;
            if (!candidateSet.has(key)) {
              candidateSet.add(key);
              newCandidates.push(c);
            }
          }
        }

        newCandidates.sort((a, b) => b.priority - a.priority);
        return newCandidates.slice(0, 12);
      }

      self.onmessage = function(e) {
        const { candidates, boardData, aiPlayer, level, personality, workerId } = e.data;
        
        board = boardData.map(row => [...row]);

        let bestMove = null;
        let bestScore = -Infinity;

        for (const candidate of candidates) {
          board[candidate.y][candidate.x] = aiPlayer;
          
          const childCandidates = generateChildCandidates(candidate.x, candidate.y, candidates, aiPlayer);
          
          const result = alphaBeta(
            level - 1,
            -Infinity,
            Infinity,
            false,
            aiPlayer,
            personality,
            childCandidates
          );
          
          board[candidate.y][candidate.x] = EMPTY;

          const score = result.score;
          if (score > bestScore) {
            bestScore = score;
            bestMove = { x: candidate.x, y: candidate.y };
          }
        }

        self.postMessage({ workerId, bestMove, bestScore });
      };
    `;

    // ========================================
    // Constants
    // ========================================
    const BOARD_SIZE = 15;
    const EMPTY = 0;
    const BLACK = 1;
    const WHITE = -1;
    const NUM_WORKERS = 4;

    // ========================================
    // Game State
    // ========================================
    let board = [];
    let currentPlayer = BLACK;
    let gameOver = false;
    let moveHistory = [];
    let scores = { black: 0, white: 0 };
    let gameMode = 'pvp';
    let winner = null;  // ÂãùËÄÖ„ÇíË®òÈå≤
    
    // AIË®≠ÂÆöÔºà„Éó„É¨„Ç§„É§„Éº vs AIÔºâ
    let aiLevel = 1;
    let aiPersonality = 'aggressive';
    let humanPlayer = BLACK;  // „Éó„É¨„Ç§„É§„Éº„ÅÆËâ≤ÔºàÂÖàÊâã/ÂæåÊâãÔºâ
    
    // AIÂêåÂ£´ÂØæÊà¶Ë®≠ÂÆö
    let blackAi = { level: 1, personality: 'aggressive' };
    let whiteAi = { level: 4, personality: 'balanced' };
    
    let isAiThinking = false;
    let battleRunning = false;
    let battlePaused = false;
    let battleTimeoutId = null;

    let workers = [];
    let workerResults = [];
    let pendingWorkers = 0;
    let currentAiResolve = null;

    // ========================================
    // Worker Setup
    // ========================================
    function initWorkers() {
      workers.forEach(w => w.terminate());
      workers = [];

      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);

      for (let i = 0; i < NUM_WORKERS; i++) {
        const worker = new Worker(url);
        worker.onmessage = handleWorkerMessage;
        workers.push(worker);
      }
    }

    function handleWorkerMessage(e) {
      const { workerId, bestMove, bestScore } = e.data;
      
      workerResults.push({ workerId, bestMove, bestScore });
      document.getElementById('worker' + workerId).classList.remove('active');
      pendingWorkers--;

      if (pendingWorkers === 0 && currentAiResolve) {
        let best = workerResults[0];
        for (const result of workerResults) {
          if (result.bestScore > best.bestScore) {
            best = result;
          }
        }
        currentAiResolve(best.bestMove);
        currentAiResolve = null;
      }
    }

    function setWorkerActive(id, active) {
      const el = document.getElementById('worker' + id);
      if (active) el.classList.add('active');
      else el.classList.remove('active');
    }

    // ========================================
    // Canvas Setup
    // ========================================
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    let cellSize, padding, boardPixelSize;

    function initCanvas() {
      const maxSize = Math.min(window.innerWidth - 32, 500);
      boardPixelSize = maxSize;
      canvas.width = boardPixelSize;
      canvas.height = boardPixelSize;
      padding = boardPixelSize * 0.04;
      cellSize = (boardPixelSize - padding * 2) / (BOARD_SIZE - 1);
    }

    // ========================================
    // Board Rendering
    // ========================================
    function drawBoard() {
      ctx.fillStyle = '#dcb35c';
      ctx.fillRect(0, 0, boardPixelSize, boardPixelSize);

      ctx.strokeStyle = '#8b7355';
      ctx.lineWidth = 1;

      for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = padding + i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, padding);
        ctx.lineTo(pos, boardPixelSize - padding);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(padding, pos);
        ctx.lineTo(boardPixelSize - padding, pos);
        ctx.stroke();
      }

      const starPoints = [
        [3, 3], [3, 7], [3, 11],
        [7, 3], [7, 7], [7, 11],
        [11, 3], [11, 7], [11, 11]
      ];

      ctx.fillStyle = '#8b7355';
      starPoints.forEach(([x, y]) => {
        const px = padding + x * cellSize;
        const py = padding + y * cellSize;
        ctx.beginPath();
        ctx.arc(px, py, cellSize * 0.12, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawStones() {
      const lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            drawStone(x, y, board[y][x], lastMove && lastMove.x === x && lastMove.y === y);
          }
        }
      }
    }

    function drawStone(x, y, player, isLast = false) {
      const px = padding + x * cellSize;
      const py = padding + y * cellSize;
      const radius = cellSize * 0.43;

      ctx.beginPath();
      ctx.arc(px + 2, py + 2, radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fill();

      const gradient = ctx.createRadialGradient(
        px - radius * 0.3, py - radius * 0.3, radius * 0.1,
        px, py, radius
      );

      if (player === BLACK) {
        gradient.addColorStop(0, '#4a4a4a');
        gradient.addColorStop(1, '#1a1a1a');
      } else {
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(1, '#cccccc');
      }

      ctx.beginPath();
      ctx.arc(px, py, radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      if (isLast) {
        ctx.beginPath();
        ctx.arc(px, py, radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = player === BLACK ? '#ff6b6b' : '#e74c3c';
        ctx.fill();
      }
    }

    function render() {
      drawBoard();
      drawStones();
    }

    // ========================================
    // Game Logic
    // ========================================
    function initBoard() {
      board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
      currentPlayer = BLACK;
      gameOver = false;
      winner = null;
      moveHistory = [];
      isAiThinking = false;
      updateStatus();
      render();
      
      // AIÂØæÊà¶„ÅßÂæåÊâãÔºàÁôΩÔºâ„ÇíÈÅ∏„Çì„Å†Â†¥Âêà„ÄÅAI„ÅåÂÖà„Å´Êâì„Å§
      if (gameMode === 'ai' && humanPlayer === WHITE) {
        triggerAiMove();
      }
    }

    function isValidMove(x, y) {
      return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[y][x] === EMPTY;
    }

    function makeMove(x, y) {
      if (!isValidMove(x, y) || gameOver || isAiThinking) return false;

      board[y][x] = currentPlayer;
      moveHistory.push({ x, y, player: currentPlayer });

      if (checkWin(x, y, currentPlayer)) {
        gameOver = true;
        winner = currentPlayer;
        render();
        updateStatus();  // ÂãùÂà©„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
        showWinner(currentPlayer);
        return true;
      }

      if (checkDraw()) {
        gameOver = true;
        winner = null;
        render();
        updateStatus();
        showDraw();
        return true;
      }

      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
      updateStatus();
      render();

      // AIÂØæÊà¶ÔºöAI„ÅÆÁï™„Å™„ÇâÊâã„ÇíÊâì„Å§
      if (gameMode === 'ai' && currentPlayer !== humanPlayer && !gameOver) {
        triggerAiMove();
      }

      return true;
    }

    function undoMove() {
      if (moveHistory.length === 0 || gameOver || isAiThinking) return;

      const undoCount = gameMode === 'ai' && moveHistory.length >= 2 ? 2 : 1;
      
      for (let i = 0; i < undoCount && moveHistory.length > 0; i++) {
        const lastMove = moveHistory.pop();
        board[lastMove.y][lastMove.x] = EMPTY;
      }

      currentPlayer = moveHistory.length % 2 === 0 ? BLACK : WHITE;
      updateStatus();
      render();
    }

    const DIRECTIONS = [[1, 0], [0, 1], [1, 1], [1, -1]];

    function checkWin(x, y, player) {
      for (const [dx, dy] of DIRECTIONS) {
        let count = 1;
        for (let i = 1; i < 5; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }
        for (let i = 1; i < 5; i++) {
          const nx = x - dx * i, ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] !== player) break;
          count++;
        }
        if (count >= 5) return true;
      }
      return false;
    }

    function checkDraw() {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === EMPTY) return false;
        }
      }
      return true;
    }

    // ========================================
    // AI
    // ========================================
    function generateCandidates() {
      if (moveHistory.length === 0) {
        return [{ x: 7, y: 7, priority: 1000000 }];
      }

      const candidateMap = new Map();
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] !== EMPTY) {
            for (let dy = -2; dy <= 2; dy++) {
              for (let dx = -2; dx <= 2; dx++) {
                const ny = y + dy, nx = x + dx;
                if (ny >= 0 && ny < BOARD_SIZE && nx >= 0 && nx < BOARD_SIZE && board[ny][nx] === EMPTY) {
                  const key = `${nx},${ny}`;
                  if (!candidateMap.has(key)) {
                    const priority = quickEvaluate(nx, ny);
                    candidateMap.set(key, { x: nx, y: ny, priority });
                  }
                }
              }
            }
          }
        }
      }

      const candidates = Array.from(candidateMap.values());
      candidates.sort((a, b) => b.priority - a.priority);
      return candidates.slice(0, 24);
    }

    function quickEvaluate(x, y) {
      // Âç≥Âãù„Å°/Âç≥Ë≤†„Åë„ÉÅ„Çß„ÉÉ„ÇØ
      board[y][x] = WHITE;
      if (checkWin(x, y, WHITE)) { board[y][x] = EMPTY; return 100000000; }
      board[y][x] = BLACK;
      if (checkWin(x, y, BLACK)) { board[y][x] = EMPTY; return 95000000; }
      board[y][x] = EMPTY;

      let score = 0;
      
      // ËÑÖÂ®ÅÂàÜÊûêÔºà‰∏°„Éó„É¨„Ç§„É§„ÉºÔºâ
      const whiteThreats = analyzeThreatsMain(x, y, WHITE);
      const blackThreats = analyzeThreatsMain(x, y, BLACK);
      
      // ÈñãÊîæÂõõ
      if (whiteThreats.openFour > 0) score += 5000000;
      if (blackThreats.openFour > 0) score += 4500000;
      
      // Âõõ‰∏â„Ç≥„É≥„Éú
      if (whiteThreats.four > 0 && whiteThreats.openThree > 0) score += 3000000;
      if (blackThreats.four > 0 && blackThreats.openThree > 0) score += 2800000;
      
      // ÂèåÂõõ
      if (whiteThreats.four >= 2) score += 2500000;
      if (blackThreats.four >= 2) score += 2300000;
      
      // Âèå‰∏â
      if (whiteThreats.openThree >= 2) score += 1500000;
      if (blackThreats.openThree >= 2) score += 1400000;
      
      // ÈÄöÂ∏∏„ÅÆËÑÖÂ®Å
      if (whiteThreats.four > 0) score += 500000;
      if (whiteThreats.openThree > 0) score += 50000;
      if (blackThreats.four > 0) score += 450000;
      if (blackThreats.openThree > 0) score += 45000;

      // ‰∏≠Â§Æ„Éú„Éº„Éä„ÇπÔºàÂº∑ÂåñÔºâ
      const dist = Math.abs(x - 7) + Math.abs(y - 7);
      score += (14 - dist) * 100;
      
      return score;
    }

    function findEmergencyMove(player) {
      const enemy = -player;
      const candidates = generateCandidates();

      // 1. Ëá™ÂàÜ„ÅåÂç≥Âãù„Å°
      for (const { x, y } of candidates) {
        board[y][x] = player;
        const win = checkWin(x, y, player);
        board[y][x] = EMPTY;
        if (win) return { x, y };
      }

      // 2. Áõ∏Êâã„ÅÆÂç≥Âãù„Å°„ÇíÈòªÊ≠¢
      for (const { x, y } of candidates) {
        board[y][x] = enemy;
        const lose = checkWin(x, y, enemy);
        board[y][x] = EMPTY;
        if (lose) return { x, y };
      }

      // 3. ÈñãÊîæÂõõ„Çí‰Ωú„Çã
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.openFour > 0) return { x, y };
      }

      // 4. Áõ∏Êâã„ÅÆÈñãÊîæÂõõ„ÇíÈòªÊ≠¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.openFour > 0) return { x, y };
      }

      // 5. Âõõ‰∏â„Ç≥„É≥„Éú„Çí‰Ωú„ÇãÔºàÂãù„Å°Á¢∫ÂÆöÔºâ
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.four > 0 && threats.openThree > 0) return { x, y };
      }

      // 6. ÂèåÂõõ„Çí‰Ωú„ÇãÔºàÂãù„Å°Á¢∫ÂÆöÔºâ
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.four >= 2) return { x, y };
      }

      // 7. Áõ∏Êâã„ÅÆÂõõ‰∏â„ÇíÈòªÊ≠¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.four > 0 && threats.openThree > 0) return { x, y };
      }

      // 8. Áõ∏Êâã„ÅÆÂèåÂõõ„ÇíÈòªÊ≠¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.four >= 2) return { x, y };
      }

      // 9. Âèå‰∏â„Çí‰Ωú„ÇãÔºàÂº∑Âäõ„Å™Êîª„ÇÅÔºâ
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, player);
        if (threats.openThree >= 2) return { x, y };
      }

      // 10. Áõ∏Êâã„ÅÆÂèå‰∏â„ÇíÈòªÊ≠¢
      for (const { x, y } of candidates) {
        const threats = analyzeThreatsMain(x, y, enemy);
        if (threats.openThree >= 2) return { x, y };
      }

      return null;
    }

    // „É°„Ç§„É≥„Çπ„É¨„ÉÉ„ÉâÁî®„ÅÆËÑÖÂ®ÅÂàÜÊûê
    function analyzeThreatsMain(x, y, player) {
      const threats = { five: 0, openFour: 0, four: 0, openThree: 0, three: 0 };
      board[y][x] = player;
      
      for (const [dx, dy] of DIRECTIONS) {
        let count = 1;
        let openEnds = 0;
        
        // Ê≠£ÊñπÂêë
        for (let i = 1; i <= 5; i++) {
          const nx = x + dx * i, ny = y + dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] === player) count++;
          else if (board[ny][nx] === EMPTY) { openEnds++; break; }
          else break;
        }
        // Ë≤†ÊñπÂêë
        for (let i = 1; i <= 5; i++) {
          const nx = x - dx * i, ny = y - dy * i;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (board[ny][nx] === player) count++;
          else if (board[ny][nx] === EMPTY) { openEnds++; break; }
          else break;
        }
        
        count = Math.min(count, 5);
        if (count >= 5) threats.five++;
        else if (count === 4 && openEnds === 2) threats.openFour++;
        else if (count === 4 && openEnds === 1) threats.four++;
        else if (count === 3 && openEnds === 2) threats.openThree++;
        else if (count === 3 && openEnds === 1) threats.three++;
      }
      
      board[y][x] = EMPTY;
      return threats;
    }

    async function calculateAiMove(level, personality, player) {
      if (moveHistory.length === 0) {
        return { x: 7, y: 7 };
      }
      if (moveHistory.length === 1) {
        const first = moveHistory[0];
        const offsets = [[1, 1], [-1, -1], [1, -1], [-1, 1], [1, 0], [0, 1]];
        for (const [dx, dy] of offsets) {
          const nx = first.x + dx, ny = first.y + dy;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === EMPTY) {
            return { x: nx, y: ny };
          }
        }
      }

      const emergency = findEmergencyMove(player);
      if (emergency) return emergency;

      const candidates = generateCandidates();
      if (candidates.length === 0) return null;
      if (candidates.length === 1) return candidates[0];

      const chunkSize = Math.ceil(candidates.length / NUM_WORKERS);
      workerResults = [];
      pendingWorkers = NUM_WORKERS;

      return new Promise((resolve) => {
        currentAiResolve = resolve;

        for (let i = 0; i < NUM_WORKERS; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, candidates.length);
          const chunk = candidates.slice(start, end);

          if (chunk.length === 0) {
            pendingWorkers--;
            if (pendingWorkers === 0) {
              let best = workerResults[0];
              for (const r of workerResults) {
                if (r.bestScore > best.bestScore) best = r;
              }
              resolve(best.bestMove);
            }
            continue;
          }

          setWorkerActive(i, true);
          workers[i].postMessage({
            candidates: chunk,
            boardData: board.map(row => [...row]),
            aiPlayer: player,
            level: level,
            personality: personality,
            workerId: i
          });
        }
      });
    }

    async function triggerAiMove() {
      isAiThinking = true;
      updateStatus();

      // AI„ÅØ‰∫∫Èñì„ÅÆÂèçÂØæ„ÅÆËâ≤
      const aiPlayer = humanPlayer === BLACK ? WHITE : BLACK;
      const move = await calculateAiMove(aiLevel, aiPersonality, aiPlayer);
      
      isAiThinking = false;
      if (move && !gameOver) {
        makeMove(move.x, move.y);
      }
    }

    // ========================================
    // AI vs AI Battle
    // ========================================
    function startBattle() {
      if (gameOver) initBoard();
      battleRunning = true;
      battlePaused = false;
      updateBattleButtons();
      runBattle();
    }

    function pauseBattle() {
      battlePaused = !battlePaused;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? '‚ñ∂Ô∏è ÂÜçÈñã' : '‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢';
      if (!battlePaused && battleRunning) runBattle();
    }

    function stopBattle() {
      battleRunning = false;
      battlePaused = false;
      if (battleTimeoutId) {
        clearTimeout(battleTimeoutId);
        battleTimeoutId = null;
      }
      isAiThinking = false;
      updateBattleButtons();
      updateStatus();
    }

    function updateBattleButtons() {
      document.getElementById('startBattleBtn').disabled = battleRunning && !battlePaused;
      document.getElementById('pauseBattleBtn').disabled = !battleRunning;
      document.getElementById('pauseBattleBtn').textContent = battlePaused ? '‚ñ∂Ô∏è ÂÜçÈñã' : '‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢';
    }

    async function runBattle() {
      if (!battleRunning || battlePaused || gameOver) return;

      isAiThinking = true;
      updateStatus();

      const currentAi = currentPlayer === BLACK ? blackAi : whiteAi;
      const move = await calculateAiMove(currentAi.level, currentAi.personality, currentPlayer);

      isAiThinking = false;

      if (move && !gameOver && battleRunning && !battlePaused) {
        makeMove(move.x, move.y);

        if (!gameOver && battleRunning && !battlePaused) {
          const speed = parseInt(document.getElementById('battleSpeed').value);
          battleTimeoutId = setTimeout(runBattle, speed);
        }
      }
    }

    // ========================================
    // UI Updates
    // ========================================
    function getAiDisplayName(level, personality) {
      if (level === 4) return 'üëπÊúÄÂº∑';
      const icons = { aggressive: 'üî•', defensive: 'üõ°Ô∏è', balanced: '‚öñÔ∏è' };
      return `Lv.${level}${icons[personality]}`;
    }

    function updateStatus() {
      const status = document.getElementById('status');
      status.classList.remove('winner');
      
      if (gameOver) {
        if (winner !== null) {
          status.classList.add('winner');
          const winnerName = winner === BLACK ? '‚ö´ Èªí' : '‚ö™ ÁôΩ';
          status.textContent = `${winnerName} „ÅÆÂãùÂà©ÔºÅ`;
        } else {
          status.textContent = 'Âºï„ÅçÂàÜ„ÅëÔºÅ';
        }
      } else if (isAiThinking) {
        if (gameMode === 'aivai') {
          const ai = currentPlayer === BLACK ? blackAi : whiteAi;
          const name = getAiDisplayName(ai.level, ai.personality);
          status.textContent = `${currentPlayer === BLACK ? '‚ö´' : '‚ö™'} ${name} ÊÄùËÄÉ‰∏≠...`;
        } else {
          const name = getAiDisplayName(aiLevel, aiPersonality);
          status.textContent = `${name} ÊÄùËÄÉ‰∏≠...`;
        }
      } else {
        if (gameMode === 'aivai') {
          const ai = currentPlayer === BLACK ? blackAi : whiteAi;
          const name = getAiDisplayName(ai.level, ai.personality);
          status.textContent = `${currentPlayer === BLACK ? '‚ö´' : '‚ö™'} ${name} „ÅÆÁï™`;
        } else {
          status.textContent = currentPlayer === BLACK ? '‚ö´ Èªí„ÅÆÁï™„Åß„Åô' : '‚ö™ ÁôΩ„ÅÆÁï™„Åß„Åô';
        }
      }
    }

    function showWinner(player) {
      const overlay = document.getElementById('winnerOverlay');
      const stone = document.getElementById('winnerStone');
      const text = document.getElementById('winnerText');

      stone.className = 'stone-icon ' + (player === BLACK ? 'black' : 'white');
      
      if (gameMode === 'aivai') {
        const ai = player === BLACK ? blackAi : whiteAi;
        text.textContent = `${getAiDisplayName(ai.level, ai.personality)} „ÅÆÂãù„Å°ÔºÅ`;
      } else if (gameMode === 'ai') {
        text.textContent = player === BLACK ? '„ÅÇ„Å™„Åü„ÅÆÂãù„Å°ÔºÅ' : 'AI„ÅÆÂãù„Å°ÔºÅ';
      } else {
        text.textContent = player === BLACK ? 'Èªí„ÅÆÂãù„Å°ÔºÅ' : 'ÁôΩ„ÅÆÂãù„Å°ÔºÅ';
      }

      if (player === BLACK) scores.black++;
      else scores.white++;
      updateScores();

      if (gameMode === 'aivai') stopBattle();

      overlay.classList.add('visible');
    }

    function showDraw() {
      const overlay = document.getElementById('winnerOverlay');
      const stone = document.getElementById('winnerStone');
      const text = document.getElementById('winnerText');

      stone.className = 'stone-icon';
      stone.style.background = 'linear-gradient(90deg, #1a1a1a 50%, #fff 50%)';
      text.textContent = 'Âºï„ÅçÂàÜ„ÅëÔºÅ';

      overlay.classList.add('visible');
    }

    function updateScores() {
      document.getElementById('blackScore').textContent = scores.black;
      document.getElementById('whiteScore').textContent = scores.white;
    }

    function updatePersonalityVisibility() {
      const row = document.getElementById('personalityRow');
      row.style.display = aiLevel === 4 ? 'none' : 'flex';
    }

    function updateAiVsAiPersonalityVisibility() {
      document.getElementById('blackPersonalityBtns').style.display = blackAi.level === 4 ? 'none' : 'flex';
      document.getElementById('whitePersonalityBtns').style.display = whiteAi.level === 4 ? 'none' : 'flex';
    }

    // ========================================
    // Event Handlers
    // ========================================
    function getGridPosition(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const gridX = Math.round((x - padding) / cellSize);
      const gridY = Math.round((y - padding) / cellSize);
      return { x: gridX, y: gridY };
    }

    canvas.addEventListener('click', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer !== humanPlayer) return;
      if (gameMode === 'aivai') return;

      const pos = getGridPosition(e.clientX, e.clientY);
      makeMove(pos.x, pos.y);
    });

    canvas.addEventListener('touchend', (e) => {
      if (gameOver || isAiThinking) return;
      if (gameMode === 'ai' && currentPlayer !== humanPlayer) return;
      if (gameMode === 'aivai') return;

      e.preventDefault();
      const touch = e.changedTouches[0];
      const pos = getGridPosition(touch.clientX, touch.clientY);
      makeMove(pos.x, pos.y);
    });

    // Mode buttons
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gameMode = btn.dataset.mode;
        
        document.getElementById('aiSelector').classList.toggle('visible', gameMode === 'ai');
        document.getElementById('aiVsAiSelector').classList.toggle('visible', gameMode === 'aivai');
        document.getElementById('battleControls').classList.toggle('visible', gameMode === 'aivai');
        document.getElementById('workerStatus').style.display = gameMode === 'pvp' ? 'none' : 'flex';
        
        stopBattle();
        initBoard();
      });
    });

    // Turn buttons (ÂÖàÊâã/ÂæåÊâã)
    document.querySelectorAll('.turn-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.turn-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        humanPlayer = btn.dataset.turn === 'black' ? BLACK : WHITE;
        initBoard();
      });
    });

    // Level buttons (AIÂØæÊà¶)
    document.querySelectorAll('.ai-selector .level-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ai-selector .level-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiLevel = parseInt(btn.dataset.level);
        updatePersonalityVisibility();
        initBoard();
      });
    });

    // Personality buttons (AIÂØæÊà¶)
    document.querySelectorAll('.ai-selector .personality-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.ai-selector .personality-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiPersonality = btn.dataset.personality;
        initBoard();
      });
    });

    // Black AI config (AIÂêåÂ£´)
    document.querySelectorAll('#blackLevelBtns .ai-config-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#blackLevelBtns .ai-config-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        blackAi.level = parseInt(btn.dataset.level);
        updateAiVsAiPersonalityVisibility();
      });
    });

    document.querySelectorAll('#blackPersonalityBtns .personality-mini').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#blackPersonalityBtns .personality-mini').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        blackAi.personality = btn.dataset.personality;
      });
    });

    // White AI config (AIÂêåÂ£´)
    document.querySelectorAll('#whiteLevelBtns .ai-config-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#whiteLevelBtns .ai-config-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        whiteAi.level = parseInt(btn.dataset.level);
        updateAiVsAiPersonalityVisibility();
      });
    });

    document.querySelectorAll('#whitePersonalityBtns .personality-mini').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#whitePersonalityBtns .personality-mini').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        whiteAi.personality = btn.dataset.personality;
      });
    });

    // Battle controls
    document.getElementById('startBattleBtn').addEventListener('click', startBattle);
    document.getElementById('pauseBattleBtn').addEventListener('click', pauseBattle);
    document.getElementById('stopBattleBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });

    // Other controls
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('resetBtn').addEventListener('click', () => {
      stopBattle();
      initBoard();
    });
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      document.getElementById('winnerOverlay').classList.remove('visible');
      initBoard();
    });

    window.addEventListener('resize', () => {
      initCanvas();
      render();
    });

    // ========================================
    // Initialize
    // ========================================
    document.getElementById('workerStatus').style.display = 'none';
    initWorkers();
    initCanvas();
    initBoard();
  </script>
</body>
</html>
